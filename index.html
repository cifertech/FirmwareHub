<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>FirmwareHub ¬∑ CiferTech</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" type="image/png" href="file:///C:/Users/CiferTech/.cursor/projects/d-Projects-Github-FirmwareHub/assets/c__Users_CiferTech_AppData_Roaming_Cursor_User_workspaceStorage_e1541f254c985e81cc5a28ba5bdeb92e_images_X_LOGO-6c3a9a16-a000-4871-aa19-e98780e7e25d.png" />

  <style>
    :root {
      --radius-xl: 20px;
      --radius-md: 12px;
    }

    body[data-theme="dark"] {
      --bg: #0d1117;
      --bg-soft: #161b22;
      --body-gradient: linear-gradient(180deg, #161b22 0%, #0d1117 100%);
      --shell-bg: rgba(22,27,34,0.98);
      --shell-border: rgba(110,118,129,0.25);
      --shell-shadow: 0 8px 32px rgba(0,0,0,0.4);
      --panel: rgba(22,27,34,0.97);
      --panel-border: rgba(110,118,129,0.25);
      --panel-overlay: rgba(249,115,22,0.35);
      --surface: rgba(13,17,23,0.9);
      --surface-strong: #161b22;
      --border: rgba(110,118,129,0.3);
      --shadow-soft: 0 4px 16px rgba(0,0,0,0.35);
      --accent: #f97316;
      --accent-soft: rgba(249,115,22,0.15);
      --accent-contrast: #010409;
      --accent-hover: #fb923c;
      --accent-active: #ea580c;
      --accent-ring: rgba(249,115,22,0.35);
      --accent-border-soft: rgba(249,115,22,0.28);
      --btn-border: rgba(255,255,255,0.12);
      --btn-shadow: 0 1px 2px rgba(0,0,0,0.28);
      --btn-shadow-hover: 0 6px 16px rgba(0,0,0,0.32);
      --btn-shadow-weak: 0 1px 2px rgba(0,0,0,0.22);
      --btn-shadow-weak-hover: 0 4px 12px rgba(0,0,0,0.28);
      --text-main: #e6edf3;
      --text-soft: #8b949e;
      --danger: #f85149;
      --danger-surface: rgba(248,81,73,0.15);
      --danger-border: rgba(248,81,73,0.5);
      --danger-text: #ffe4e1;
      --input-bg: rgba(13,17,23,0.95);
      --tag-dot-online: #4ade80;
    }

    body[data-theme="light"] {
      --bg: #f0f2f5;
      --bg-soft: #ffffff;
      --body-gradient: linear-gradient(180deg, #ffffff 0%, #f0f2f5 100%);
      --shell-bg: rgba(255,255,255,0.98);
      --shell-border: rgba(31,35,40,0.1);
      --shell-shadow: 0 8px 32px rgba(31,35,40,0.12);
      --panel: rgba(255,255,255,0.98);
      --panel-border: rgba(31,35,40,0.1);
      --panel-overlay: rgba(249,115,22,0.25);
      --surface: rgba(246,248,250,0.95);
      --surface-strong: #ffffff;
      --border: rgba(31,35,40,0.12);
      --shadow-soft: 0 4px 16px rgba(31,35,40,0.08);
      --accent: #ea580c;
      --accent-soft: rgba(249,115,22,0.12);
      --accent-contrast: #ffffff;
      --accent-hover: #f97316;
      --accent-active: #c2410c;
      --accent-ring: rgba(234,88,12,0.28);
      --accent-border-soft: rgba(234,88,12,0.22);
      --btn-border: rgba(31,35,40,0.14);
      --btn-shadow: 0 1px 2px rgba(31,35,40,0.16);
      --btn-shadow-hover: 0 6px 16px rgba(31,35,40,0.18);
      --btn-shadow-weak: 0 1px 2px rgba(31,35,40,0.12);
      --btn-shadow-weak-hover: 0 4px 12px rgba(31,35,40,0.14);
      --text-main: #1f2937;
      --text-soft: #6b7280;
      --danger: #cf222e;
      --danger-surface: rgba(207,34,46,0.1);
      --danger-border: rgba(207,34,46,0.35);
      --danger-text: #8c1b23;
      --input-bg: #ffffff;
      --tag-dot-online: #1a7f37;
    }

    * {
      box-sizing: border-box;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Inter",
        "SF Pro Text", sans-serif;
    }

    body {
      margin: 0;
      min-height: 100vh;
      background: var(--bg);
      background-image: var(--body-gradient);
      color: var(--text-main);
      display: flex;
      justify-content: center;
      align-items: stretch;
      padding: 32px 16px;
      position: relative;
      z-index: 0;
      transition:
        background 0.3s ease,
        color 0.3s ease;
    }

    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background:
        radial-gradient(circle at 20% 20%, rgba(249,115,22,0.06), transparent 40%),
        radial-gradient(circle at 80% 80%, rgba(251,146,60,0.04), transparent 40%);
      opacity: 1;
      pointer-events: none;
      z-index: -1;
    }

    .shell {
      width: 100%;
      max-width: 1200px;
      background: var(--shell-bg);
      border-radius: 24px;
      border: 1px solid var(--shell-border);
      box-shadow: var(--shell-shadow);
      padding: 24px 28px 28px;
      backdrop-filter: blur(20px);
      display: flex;
      flex-direction: column;
      gap: 22px;
      position: relative;
      overflow: hidden;
    }

    .shell::after {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: 24px;
      border: 1px solid rgba(255,255,255,0.04);
      pointer-events: none;
    }

    body[data-theme="light"] .shell::after {
      border-color: rgba(0,0,0,0.03);
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      flex-wrap: wrap;
      padding-bottom: 16px;
      border-bottom: 1px solid var(--border);
    }

    .brand {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .brand-heading {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: baseline;
    }

    .brand-title {
      font-size: 24px;
      font-weight: 800;
      letter-spacing: -0.02em;
      color: var(--text-main);
    }

    .brand-sub {
      font-size: 12px;
      color: var(--text-soft);
      letter-spacing: 0.04em;
      text-transform: none;
    }

    .brand-pills {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .brand-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 5px 10px;
      border-radius: 999px;
      font-size: 11px;
      letter-spacing: 0.06em;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text-soft);
      text-transform: none;
    }

    .brand-pill.accent {
      border-color: var(--accent);
      color: var(--accent);
      background: var(--accent-soft);
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: flex-end;
    }

    .header-actions .tag {
      margin-right: 4px;
    }

    .docs-link {
      font-size: 12px;
      letter-spacing: 0.08em;
      color: var(--accent);
      border: 1px solid var(--border);
      border-radius: 999px;
      padding: 6px 12px;
      text-decoration: none;
      background: var(--surface);
      transition:
        border-color 0.2s ease,
        color 0.2s ease,
        background 0.2s ease;
    }

    .docs-link:hover {
      border-color: var(--accent);
      background: var(--accent-soft);
      color: var(--accent);
    }

    .support-link {
      font-size: 12px;
      letter-spacing: 0.08em;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      color: #ffffff;
      border-radius: 999px;
      padding: 7px 14px;
      text-decoration: none;
      background: linear-gradient(135deg, #f97316, #f43f5e);
      box-shadow: 0 14px 30px rgba(244,63,94,0.35);
      transition:
        transform 0.2s ease,
        box-shadow 0.2s ease;
      text-transform: none;
    }

    .support-link:hover {
      transform: translateY(-1px);
      box-shadow: 0 18px 36px rgba(244,63,94,0.45);
    }

    .remote-meta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 6px;
    }

    .remote-search-row {
      display: flex;
      flex-wrap: wrap;
      align-items: flex-end;
      gap: 8px;
      margin-bottom: 8px;
    }

    .remote-search-row input[type="text"] {
      flex: 1 1 220px;
    }

    .remote-toggle {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text-soft);
      font-size: 11px;
      letter-spacing: 0.02em;
      user-select: none;
      cursor: pointer;
      white-space: nowrap;
    }

    .remote-toggle input {
      accent-color: var(--accent);
    }

    /* Remote releases grouped by tag */
    .release-group {
      margin: 0 0 8px 0;
    }

    .release-details {
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--surface);
      overflow: hidden;
    }

    .release-details[open] {
      background: var(--surface-strong);
    }

    .release-summary {
      list-style: none;
      cursor: pointer;
      padding: 10px 12px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      border-bottom: 1px solid rgba(0,0,0,0);
    }

    .release-details[open] .release-summary {
      border-bottom-color: var(--border);
    }

    .release-summary::-webkit-details-marker {
      display: none;
    }

    .release-summary-main {
      min-width: 0;
      display: flex;
      flex-direction: column;
      gap: 2px;
    }

    .release-title {
      font-size: 12px;
      font-weight: 700;
      color: var(--text-main);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 520px;
    }

    .release-subtitle {
      font-size: 11px;
      color: var(--text-soft);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 520px;
    }

    .release-summary-meta {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      flex-wrap: wrap;
      gap: 6px;
      flex: 0 0 auto;
    }

    .release-badge {
      font-size: 10px;
      padding: 2px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: var(--surface);
      color: var(--text-soft);
      letter-spacing: 0.04em;
      text-transform: none;
    }

    .release-badge.prerelease {
      border-color: var(--danger-border);
      background: var(--danger-surface);
      color: var(--danger-text);
    }

    .release-assets {
      list-style: none;
      padding: 10px 10px 8px;
      margin: 0;
    }

    .release-assets .github-item {
      margin-bottom: 6px;
    }

    .release-assets .github-item[aria-disabled="true"] {
      opacity: 0.55;
      cursor: not-allowed;
    }

    .github-item .github-item-right {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      flex: 0 0 auto;
    }

    .auto-refresh-status {
      font-size: 11px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text-soft);
    }

    .tag {
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 11px;
      color: var(--text-soft);
      display: inline-flex;
      align-items: center;
      gap: 6px;
      background: var(--surface);
    }

    .tag-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: var(--tag-dot-online);
      box-shadow: 0 0 10px var(--tag-dot-online);
    }

    .grid {
      display: grid;
      gap: 18px;
    }

    /* Main app layout */
    .layout-main {
      margin-top: 4px;
      display: grid;
      grid-template-columns: minmax(0, 1.4fr) minmax(0, 1fr);
      gap: 22px;
      align-items: flex-start;
    }

    .layout-col {
      display: flex;
      flex-direction: column;
      gap: 16px;
      min-width: 0;
    }

    .layout-col-primary {
      order: 1;
    }

    .layout-col-secondary {
      order: 2;
    }

    @media (max-width: 900px) {
      .layout-main {
        grid-template-columns: 1fr;
      }

      .layout-col-primary,
      .layout-col-secondary {
        order: unset;
      }

      .shell {
        padding: 18px 16px 22px;
      }

      body {
        padding: 20px 12px;
      }
    }

    @media (max-width: 600px) {
      header {
        flex-direction: column;
        align-items: flex-start;
      }

      .header-actions {
        width: 100%;
        justify-content: flex-start;
      }

      .stats-grid {
        grid-template-columns: 1fr;
      }
    }

    .shell-footer {
      margin-top: 8px;
      padding-top: 14px;
      border-top: 1px solid var(--border);
      font-size: 11px;
      color: var(--text-soft);
      text-align: right;
      letter-spacing: 0.02em;
    }

    /* Main tabs */
    .main-tabs {
      display: flex;
      gap: 4px;
      padding: 0 2px;
      margin-bottom: 18px;
      border-bottom: 1px solid var(--border);
      flex-wrap: wrap;
    }

    .main-tabs [role="tab"] {
      padding: 10px 18px;
      font-size: 13px;
      font-weight: 600;
      line-height: 1;
      color: var(--text-soft);
      background: transparent;
      border: 1px solid transparent;
      border-radius: 10px 10px 0 0;
      cursor: pointer;
      position: relative;
      bottom: -1px;
      margin-bottom: -1px;
      transition: color 0.2s ease, background 0.2s ease;
      box-shadow: none;
    }

    .main-tabs [role="tab"]:hover {
      color: var(--text-main);
      background: var(--surface);
    }

    .main-tabs [role="tab"][aria-selected="true"] {
      color: var(--accent);
      background: var(--panel);
      border-color: var(--border);
      border-bottom-color: var(--panel);
    }

    /* Tab pages */
    .tab-page {
      display: none;
    }

    .tab-page.active {
      display: block;
    }

    /* Flash source sub-tabs (Local | Remote) */
    .flash-source-tabs {
      display: flex;
      gap: 4px;
      margin: -4px 0 0;
    }

    .flash-source-tabs [role="tab"] {
      padding: 8px 16px;
      font-size: 12px;
      font-weight: 600;
      line-height: 1;
      color: var(--text-soft);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 10px 10px 0 0;
      cursor: pointer;
      transition: color 0.2s ease, background 0.2s ease, border-color 0.2s ease;
      box-shadow: none;
    }

    .flash-source-tabs [role="tab"]:hover {
      color: var(--text-main);
      background: var(--surface-strong);
    }

    .flash-source-tabs [role="tab"][aria-selected="true"] {
      color: var(--accent);
      background: var(--panel);
      border-color: var(--panel-border);
      border-bottom-color: var(--panel);
    }

    /* Section divider */
    .section-divider {
      height: 1px;
      background: var(--border);
      margin: 8px 0 16px;
    }

    .section-heading {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--text-soft);
      margin: 16px 0 8px;
    }

    .section-heading:first-child {
      margin-top: 0;
    }

    /* Content blocks inside panels */
    .panel-block {
      padding: 14px 0;
      border-top: 1px solid var(--border);
    }

    .panel-block:first-of-type {
      border-top: none;
      padding-top: 0;
    }

    .panel-block .block-title {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--text-soft);
      margin: 0 0 10px;
    }

    .panel-block .block-title:not(:first-child) {
      margin-top: 4px;
    }

    .panel-block > .row + .row,
    .panel-block > .row + .hint,
    .panel-block > .hint + .row {
      margin-top: 8px;
    }

    .main-tabs + .tab-page .layout-main {
      margin-top: 2px;
    }

    .flash-source-tabs {
      margin-bottom: 4px;
    }

    .layout-col .panel + .flash-source-tabs,
    .flash-source-tabs + .panel {
      margin-top: 2px;
    }

    .console-panel-full,
    .stats-panel-full {
      max-width: 720px;
    }

    .log-panel .panel-body pre {
      min-height: 180px;
      max-height: 320px;
    }

    .grid-2 {
      grid-template-columns: 1.1fr 1fr;
    }

    .grid-2-bottom {
      grid-template-columns: 1fr 1.2fr;
    }

    @media (max-width: 900px) {
      .grid-2,
      .grid-2-bottom {
        grid-template-columns: 1fr;
      }
    }

    .panel {
      background: var(--panel);
      border-radius: 18px;
      border: 1px solid var(--panel-border);
      box-shadow: var(--shadow-soft);
      padding: 20px 20px 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      position: relative;
      overflow: hidden;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .panel:hover {
      border-color: rgba(249,115,22,0.35);
      box-shadow: 0 8px 24px rgba(0,0,0,0.12);
    }

    body[data-theme="light"] .panel:hover {
      box-shadow: 0 8px 24px rgba(31,35,40,0.06);
    }

    .panel::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: var(--panel-overlay);
      pointer-events: none;
      border-radius: 18px 18px 0 0;
    }

    .panel-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      z-index: 1;
    }

    .panel-title-row {
      display: inline-flex;
      align-items: baseline;
      gap: 6px;
      flex-wrap: wrap;
    }

    .panel-title {
      font-size: 12px;
      font-weight: 600;
      letter-spacing: 0.1em;
      color: var(--text-soft);
      text-transform: uppercase;
    }

    .panel-step {
      font-size: 10px;
      letter-spacing: 0.06em;
      text-transform: uppercase;
      color: var(--accent);
      background: var(--accent-soft);
      border-radius: 999px;
      padding: 3px 9px;
    }

    .badge,
    .label-chip {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--text-soft);
      background: var(--surface);
    }

    .panel-body {
      z-index: 1;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .row {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    /* Region tools (Connect tab) */
    .region-tools {
      display: flex;
      align-items: flex-end;
      justify-content: flex-start;
      gap: 10px;
      flex-wrap: wrap;
      padding: 10px 10px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--surface);
    }

    .region-tools .region-fields {
      display: flex;
      align-items: flex-end;
      flex-wrap: wrap;
      gap: 10px;
      flex: 1 1 320px;
    }

    .region-tools .region-field {
      display: flex;
      flex-direction: column;
      gap: 6px;
      min-width: 140px;
    }

    .region-tools .region-input {
      width: 100%;
    }

    .region-tools .region-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: flex-end;
      margin-left: auto;
      align-self: flex-end;
    }

    @media (max-width: 600px) {
      .region-tools {
        flex-direction: column;
        align-items: stretch;
      }

      .region-tools .region-field {
        min-width: 0;
        flex: 1 1 100%;
      }

      .region-tools .region-actions {
        width: 100%;
        justify-content: stretch;
      }

      .region-tools .region-actions button {
        flex: 1 1 140px;
      }
    }

    .pill {
      font-size: 11px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--text-soft);
    }

    button {
      border-radius: var(--radius-md);
      border: 1px solid var(--btn-border);
      padding: 10px 14px;
      min-height: 38px;
      font-size: 13px;
      font-weight: 600;
      line-height: 1;
      cursor: pointer;
      background: var(--accent);
      color: var(--accent-contrast);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
      transition:
        background 0.15s ease,
        color 0.15s ease,
        border-color 0.15s ease,
        box-shadow 0.15s ease,
        transform 0.05s ease;
      box-shadow: var(--btn-shadow);
    }

    button:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px var(--accent-ring), var(--btn-shadow-hover);
    }

    button.secondary:focus-visible,
    button.btn-secondary:focus-visible,
    button.danger:focus-visible,
    button.btn-danger:focus-visible {
      box-shadow: 0 0 0 3px var(--accent-ring);
    }

    .main-tabs [role="tab"]:focus-visible,
    .flash-source-tabs [role="tab"]:focus-visible {
      outline: none;
      box-shadow: 0 0 0 2px var(--accent-ring);
    }

    .docs-link:focus-visible,
    a.link:focus-visible {
      outline: 2px solid var(--accent);
      outline-offset: 2px;
    }

    button:not(:disabled):hover {
      background: var(--accent-hover);
      box-shadow: var(--btn-shadow-hover);
    }

    button:not(:disabled):active:not([role="tab"]):not(.secondary):not(.btn-secondary):not(.danger):not(.btn-danger) {
      background: var(--accent-active);
      box-shadow: var(--btn-shadow);
      transform: translateY(1px);
    }

    button.secondary,
    button.btn-secondary {
      background: var(--surface);
      color: var(--text-main);
      border: 1px solid var(--border);
      box-shadow: none;
    }

    button.secondary:not(:disabled):hover,
    button.btn-secondary:not(:disabled):hover {
      background: var(--surface-strong);
      border-color: var(--accent-border-soft);
      box-shadow: var(--btn-shadow-weak-hover);
    }

    button.secondary:not(:disabled):active:not([role="tab"]),
    button.btn-secondary:not(:disabled):active:not([role="tab"]) {
      background: var(--surface-strong);
      border-color: var(--accent-border-soft);
      box-shadow: var(--btn-shadow-weak);
      transform: translateY(1px);
    }

    button.danger,
    button.btn-danger {
      background: var(--danger-surface);
      color: var(--danger-text);
      border: 1px solid var(--danger-border);
      box-shadow: none;
    }

    button.danger:not(:disabled):hover,
    button.btn-danger:not(:disabled):hover {
      background: var(--danger-surface);
      border-color: var(--danger);
    }

    button.danger:not(:disabled):active:not([role="tab"]),
    button.btn-danger:not(:disabled):active:not([role="tab"]) {
      background: var(--danger-surface);
      transform: translateY(1px);
      box-shadow: none;
    }

    .btn-small {
      padding: 7px 12px;
      min-height: 32px;
      font-size: 12px;
      border-radius: 10px;
    }

    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }

    button.secondary:disabled,
    button.btn-secondary:disabled {
      background: var(--surface);
      border-color: var(--border);
      box-shadow: none;
    }

    .btn-icon,
    .theme-toggle {
      width: 34px;
      height: 32px;
      padding: 0;
    }

    @media (prefers-reduced-motion: reduce) {
      button,
      .main-tabs [role="tab"],
      .flash-source-tabs [role="tab"],
      .docs-link,
      a.link {
        transition: none !important;
      }

      button:not(:disabled):active:not([role="tab"]) {
        transform: none !important;
      }
    }

    input[type="file"],
    input[type="text"],
    select,
    textarea {
      width: 100%;
      background: var(--input-bg);
      border-radius: 10px;
      border: 1px solid var(--border);
      color: var(--text-main);
      font-size: 13px;
      padding: 10px 12px;
      min-height: 38px;
      line-height: 1;
      outline: none;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    select {
      padding-right: 42px;
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      background-image:
        linear-gradient(45deg, transparent 50%, var(--text-soft) 50%),
        linear-gradient(135deg, var(--text-soft) 50%, transparent 50%);
      background-position:
        calc(100% - 18px) 50%,
        calc(100% - 12px) 50%;
      background-size: 6px 6px, 6px 6px;
      background-repeat: no-repeat;
    }

    select::-ms-expand {
      display: none;
    }

    input[type="text"]:focus,
    select:focus,
    textarea:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px var(--accent-ring);
    }

    textarea {
      resize: vertical;
      min-height: 70px;
      max-height: 150px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
    }

    .label {
      font-size: 11px;
      color: var(--text-soft);
      letter-spacing: 0.08em;
    }

    .value {
      font-size: 12px;
      color: var(--text-main);
      word-wrap: break-word;
    }

    .value-soft {
      font-size: 12px;
      color: var(--text-soft);
    }

    .metric-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
      gap: 10px;
    }

    .metric {
      background: var(--surface);
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 10px 12px;
      min-height: 56px;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .metric:hover {
      border-color: rgba(249,115,22,0.25);
      background: var(--surface-strong);
    }

    .metric-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-soft);
    }

    .metric-value {
      font-size: 14px;
      font-weight: 600;
      margin-top: 4px;
      color: var(--text-main);
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: #f97316;
      box-shadow: 0 0 8px #f97316;
      margin-right: 4px;
    }

    .status-dot.connected {
      background: #22c55e;
      box-shadow: 0 0 8px #22c55e;
    }

    .status-text {
      font-size: 11px;
      color: var(--text-soft);
    }

    .dropzone {
      border-radius: 14px;
      border: 2px dashed var(--border);
      padding: 20px 16px;
      text-align: center;
      cursor: pointer;
      background: var(--surface);
      transition: border-color 0.2s ease, background 0.2s ease;
      font-size: 13px;
      color: var(--text-soft);
    }

    .dropzone:hover {
      border-color: var(--accent);
      background: var(--surface-strong);
    }

    .dropzone span {
      color: var(--accent);
      font-weight: 600;
    }

    .filename {
      font-size: 12px;
      margin-top: 8px;
      color: var(--text-soft);
    }

    .progress {
      width: 100%;
      height: 8px;
      border-radius: 999px;
      background: var(--surface);
      border: 1px solid var(--border);
      overflow: hidden;
      margin-top: 6px;
    }

    .progress-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, #fed7aa, #fb923c, #f97316);
      background-size: 200% 100%;
      animation: progressAnim 1.2s linear infinite;
      transition: width 0.2s ease;
    }

    @keyframes progressAnim {
      from { background-position: 0% 0%; }
      to   { background-position: 200% 0%; }
    }

    pre {
      background: var(--surface-strong);
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 12px 14px;
      font-size: 12px;
      line-height: 1.5;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
      max-height: 160px;
      overflow-y: auto;
      color: var(--text-main);
    }

    .log-tag {
      font-size: 11px;
      font-weight: 600;
      letter-spacing: 0.04em;
      color: var(--text-soft);
      margin-bottom: 4px;
    }

    .history-list,
    .github-list {
      max-height: 140px;
      overflow-y: auto;
      padding: 0;
      margin: 6px 0 0;
      list-style: none;
      font-size: 12px;
    }

    #githubList.github-list {
      max-height: 260px;
      margin-top: 10px;
    }

    .project-cards {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 10px;
      max-height: 180px;
      overflow-y: auto;
      padding: 0;
      margin: 8px 0 0;
    }

    .project-card {
      border-radius: 12px;
      border: 1px solid var(--border);
      background: var(--surface);
      padding: 12px 12px 10px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      gap: 6px;
      transition: border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .project-card:hover {
      border-color: rgba(249,115,22,0.5);
      box-shadow: 0 4px 12px rgba(0,0,0,0.08);
    }

    .project-card.active {
      border-color: var(--accent);
      box-shadow: 0 0 0 2px rgba(249,115,22,0.25);
    }

    .project-card-title {
      font-size: 13px;
      font-weight: 600;
    }

    .project-card-desc {
      font-size: 11px;
      color: var(--text-soft);
      line-height: 1.35;
    }

    .project-card-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .project-card-tag {
      font-size: 9px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--text-soft);
      background: var(--surface-strong);
    }

    .changelog-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.75);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: 20px;
    }

    .changelog-modal.visible {
      display: flex;
    }

    .changelog-content {
      background: var(--shell-bg);
      border-radius: var(--radius-xl);
      border: 1px solid var(--shell-border);
      max-width: 700px;
      width: 100%;
      max-height: 80vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: var(--shell-shadow);
    }

    .changelog-header {
      padding: 16px 20px;
      border-bottom: 1px solid var(--border);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .changelog-title {
      font-size: 16px;
      font-weight: 600;
    }

    .changelog-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }

    .changelog-release {
      margin-bottom: 20px;
      padding-bottom: 20px;
      border-bottom: 1px solid var(--border);
    }

    .changelog-release:last-child {
      border-bottom: none;
    }

    .changelog-release-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .changelog-version {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent);
    }

    .changelog-date {
      font-size: 11px;
      color: var(--text-soft);
    }

    .changelog-notes {
      font-size: 12px;
      line-height: 1.6;
      color: var(--text-main);
      white-space: pre-wrap;
    }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-top: 8px;
    }

    .stat-card {
      background: var(--surface);
      border-radius: 12px;
      border: 1px solid var(--border);
      padding: 14px 12px;
      text-align: center;
      transition: border-color 0.2s ease, background 0.2s ease;
    }

    .stat-card:hover {
      border-color: rgba(249,115,22,0.2);
      background: var(--surface-strong);
    }

    .stat-value {
      font-size: 22px;
      font-weight: 700;
      color: var(--accent);
      margin-bottom: 4px;
      letter-spacing: -0.02em;
    }

    .stat-label {
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-soft);
    }

    .notification-badge {
      position: absolute;
      top: -4px;
      right: -4px;
      background: #f97316;
      color: white;
      font-size: 10px;
      font-weight: 700;
      padding: 2px 6px;
      border-radius: 999px;
      box-shadow: 0 2px 8px rgba(249,115,22,0.5);
    }

    .submission-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
    }

    .submission-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    .history-item,
    .github-item {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid var(--border);
      border-left: 3px solid transparent;
      background: var(--surface);
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      margin-bottom: 6px;
      transition: border-color 0.2s ease, background 0.2s ease;
      cursor: pointer;
    }

    .github-item:hover,
    .history-item:hover {
      background: var(--surface-strong);
      border-color: rgba(249,115,22,0.2);
    }

    .history-item span,
    .github-item span {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 180px;
    }

    .label-chip {
      font-size: 11px;
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      color: var(--text-soft);
      background: var(--surface);
    }

    .console-input-row {
      display: flex;
      gap: 6px;
      margin-top: 6px;
    }

    .console-input-row input {
      flex: 1;
    }

    .multi-file-container {
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 8px;
    }

    .multi-file-row {
      display: flex;
      align-items: center;
      gap: 10px;
      flex-wrap: wrap;
      padding: 8px 10px;
      background: var(--surface);
      border-radius: 10px;
      border: 1px solid var(--border);
    }

    .multi-file-row .file-label {
      min-width: 120px;
      font-size: 12px;
      color: var(--text-soft);
      cursor: pointer;
      text-decoration: underline;
    }

    .multi-file-row .file-label.has-file {
      color: var(--accent);
    }

    .multi-file-row input[type="file"] {
      width: 0;
      height: 0;
      opacity: 0;
      position: absolute;
    }

    .multi-file-row .addr-input {
      width: 90px;
      font-family: ui-monospace, monospace;
      font-size: 12px;
    }

    .multi-file-row .remove-row {
      min-height: 32px;
      padding: 7px 10px;
      font-size: 11px;
    }

    .release-set-preview {
      margin-top: 8px;
      font-size: 11px;
      color: var(--text-soft);
    }

    .release-set-preview .preview-row {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 4px 0;
    }

    .release-set-preview .preview-addr {
      font-family: ui-monospace, monospace;
      min-width: 56px;
      color: var(--accent);
    }

    .hint {
      font-size: 11px;
      color: var(--text-soft);
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas,
        "Liberation Mono", "Courier New", monospace;
    }

    a.link {
      color: var(--accent);
      text-decoration: none;
      font-size: 11px;
    }

    a.link:hover {
      text-decoration: underline;
    }
    .theme-toggle {
      width: 34px;
      height: 32px;
      padding: 0;
      font-size: 16px;
    }

    .theme-toggle span {
      line-height: 1;
    }

    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--border);
      border-radius: 999px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--accent);
    }
  </style>
</head>

<body data-theme="dark">
<div class="shell">
  <header>
    <div class="brand">
      <div class="brand-heading">
        <div class="brand-title">FirmwareHub</div>
        <div class="brand-sub">Created by CiferTech ¬∑ ESP32 / ESP8266 Browser Flasher</div>
      </div>
      <div class="brand-pills">
        <span class="brand-pill accent">WebSerial Ready</span>
        <span class="brand-pill">Secure USB</span>
        <span class="brand-pill">OTA Helper</span>
      </div>
    </div>
    <div class="header-actions">
      <div class="tag">
        <div id="connDot" class="tag-dot"></div>
        <span id="connLabel">No device</span>
      </div>
      <a class="docs-link" href="https://github.com/cifertech" target="_blank" rel="noreferrer">
        Docs &amp; Repo
      </a>
      <a class="support-link" href="https://www.patreon.com/cifertech" target="_blank" rel="noreferrer">
        ‚ù§Ô∏è Support on Patreon
      </a>
      <button id="themeToggle" class="secondary btn-small theme-toggle" aria-label="Switch theme" title="Toggle theme">
        <span id="themeToggleIcon">üåô</span>
      </button>
    </div>
  </header>

  <main>
    <nav class="main-tabs" role="tablist" aria-label="Main sections">
      <button type="button" role="tab" id="main-tab-connect" data-tab="connect" aria-selected="true" aria-controls="tab-page-connect">Connect</button>
      <button type="button" role="tab" id="main-tab-local" data-tab="local" aria-selected="false" aria-controls="tab-page-local">Local Flash</button>
      <button type="button" role="tab" id="main-tab-remote" data-tab="remote" aria-selected="false" aria-controls="tab-page-remote">Remote Flash</button>
      <button type="button" role="tab" id="main-tab-console" data-tab="console" aria-selected="false" aria-controls="tab-page-console">Console</button>
      <button type="button" role="tab" id="main-tab-stats" data-tab="stats" aria-selected="false" aria-controls="tab-page-stats">Statistics</button>
    </nav>

    <!-- Connect tab -->
    <div id="tab-page-connect" class="tab-page active" role="tabpanel" aria-labelledby="main-tab-connect">
      <div class="layout-main">
        <div class="layout-col layout-col-primary">
          <section class="panel" id="section-device">
            <div class="panel-header">
              <div class="panel-title-row">
                <div class="panel-title">Device</div>
                <span class="panel-step">Step 1 ¬∑ Connect</span>
              </div>
              <div class="badge mono" id="chipFamilyBadge">No chip</div>
            </div>
            <div class="panel-body">
              <div class="panel-block">
                <div class="block-title">Connection</div>
                <div class="row">
                  <button id="connectBtn">
                    <span>üîå Connect &amp; Detect</span>
                  </button>
                  <button id="disconnectBtn" class="secondary btn-small" disabled>Disconnect</button>
                </div>
                <div class="row" style="margin-top:8px;align-items:center;">
                  <div class="status-dot" id="statusDot"></div>
                  <div class="status-text" id="statusText">Idle</div>
                </div>
                <div class="hint" style="margin-top:8px;">
                  Hold <span class="mono">BOOT</span> while clicking Connect if detection fails.
                </div>
              </div>

              <div class="panel-block">
                <div class="block-title">Chip info</div>
                <div class="metric-grid">
                  <div class="metric">
                    <div class="metric-label">Chip</div>
                    <div class="metric-value mono" id="chipName">‚Äî</div>
                  </div>
                  <div class="metric">
                    <div class="metric-label">Flash ID</div>
                    <div class="metric-value mono" id="flashId">‚Äî</div>
                  </div>
                  <div class="metric">
                    <div class="metric-label">Flash Size</div>
                    <div class="metric-value mono" id="flashSize">‚Äî</div>
                  </div>
                  <div class="metric">
                    <div class="metric-label">MAC</div>
                    <div class="metric-value mono" id="macAddr">‚Äî</div>
                  </div>
                </div>
              </div>

              <div class="panel-block">
                <div class="block-title">Region tools (read / erase / MD5)</div>
                <div class="region-tools" aria-label="Region tools">
                  <div class="region-fields">
                    <div class="region-field">
                      <label class="label" for="regionAddressInput">Address (hex)</label>
                      <input id="regionAddressInput" type="text" class="mono region-input" value="0x0" placeholder="0x0" inputmode="text" autocomplete="off" />
                    </div>
                    <div class="region-field">
                      <label class="label" for="regionSizeInput">Size (hex or bytes)</label>
                      <input id="regionSizeInput" type="text" class="mono region-input" value="0x1000" placeholder="0x1000" inputmode="text" autocomplete="off" title="e.g. 0x1000 or 4096" />
                    </div>
                  </div>

                  <div class="region-actions" role="group" aria-label="Region actions">
                    <button id="readFlashBtn" class="secondary btn-small">Read flash</button>
                    <button id="eraseRegionBtn" class="secondary btn-small">Erase region</button>
                    <button id="md5FlashBtn" class="secondary btn-small">MD5</button>
                  </div>
                </div>
                <div class="hint" style="margin-top:6px;">Read downloads a .bin. Erase wipes the region. MD5 shows checksum in flasher log.</div>
              </div>
            </div>
          </section>
        </div>
        <div class="layout-col layout-col-secondary" id="flasher-log-host-connect">
          <section class="panel log-panel" id="flasher-log-panel">
            <div class="panel-header">
              <div class="panel-title-row">
                <div class="panel-title">Flasher log</div>
              </div>
            </div>
            <div class="panel-body">
              <pre id="log"></pre>
            </div>
          </section>
        </div>
      </div>
    </div>

    <!-- Local Flash tab -->
    <div id="tab-page-local" class="tab-page" role="tabpanel" aria-labelledby="main-tab-local">
      <div class="layout-main">
        <div class="layout-col layout-col-primary">
          <section class="panel" id="section-local">
            <div class="panel-header">
              <div class="panel-title-row">
                <div class="panel-title">Local Firmware</div>
                <span class="panel-step">.bin ¬∑ Multi-file</span>
              </div>
              <div class="badge">Merged ¬∑ Offset 0x0</div>
            </div>
            <div class="panel-body">
              <div class="panel-block">
                <div class="block-title">File</div>
                <div id="dropzone" class="dropzone">
                  <div>Drop a <span>.bin</span> here or click to browse</div>
                  <div id="filename" class="filename">No file selected</div>
                  <input id="firmwareInput" type="file" accept=".bin" style="display:none;" />
                </div>
              </div>
              <div class="panel-block">
                <div class="block-title">Flash options</div>
                <div class="row" style="align-items: flex-end;">
                  <div>
                    <div class="label">Address (hex)</div>
                    <input id="flashAddressInput" type="text" class="mono" value="0x0" placeholder="0x0" style="width:100px;" title="e.g. 0x0, 0x10000" />
                  </div>
                  <div>
                    <div class="label">Size</div>
                    <select id="flashSizeSelect" style="width:auto;">
                      <option value="keep" selected>Keep</option>
                      <option value="256KB">256KB</option>
                      <option value="512KB">512KB</option>
                      <option value="1MB">1MB</option>
                      <option value="2MB">2MB</option>
                      <option value="4MB">4MB</option>
                      <option value="8MB">8MB</option>
                      <option value="16MB">16MB</option>
                    </select>
                  </div>
                  <div>
                    <div class="label">Mode</div>
                    <select id="flashModeSelect" style="width:auto;">
                      <option value="keep" selected>Keep</option>
                      <option value="qio">QIO</option>
                      <option value="qout">QOUT</option>
                      <option value="dio">DIO</option>
                      <option value="dout">DOUT</option>
                    </select>
                  </div>
                  <div>
                    <div class="label">Freq</div>
                    <select id="flashFreqSelect" style="width:auto;">
                      <option value="keep" selected>Keep</option>
                      <option value="40m">40 MHz</option>
                      <option value="80m">80 MHz</option>
                    </select>
                  </div>
                </div>
              </div>
              <div class="panel-block">
                <div class="block-title">Progress</div>
                <div class="progress">
                  <div id="progressBar" class="progress-bar"></div>
                </div>
              </div>
              <div class="panel-block">
                <div class="block-title">Actions</div>
                <div class="row">
                  <button id="flashLocalBtn">üöÄ Flash Local Firmware</button>
                  <button id="eraseBtn" class="secondary btn-small">Erase Flash (Full)</button>
                </div>
              </div>
              <div class="panel-block">
                <div class="block-title">Multi-file flash</div>
                <div class="hint" style="margin-bottom:8px;">Bootloader + partition + app: add each .bin with its address, then Flash all.</div>
                <div id="multiFileContainer" class="multi-file-container"></div>
                <div class="row" style="margin-top:8px;">
                  <button id="addMultiFileBtn" class="secondary btn-small">+ Add file + address</button>
                  <button id="flashAllMultiBtn" class="btn-small">Flash all</button>
                </div>
              </div>
            </div>
          </section>
        </div>
        <div class="layout-col layout-col-secondary" id="flasher-log-host-local"></div>
      </div>
    </div>

    <!-- Remote Flash tab -->
    <div id="tab-page-remote" class="tab-page" role="tabpanel" aria-labelledby="main-tab-remote">
      <div class="layout-main">
        <div class="layout-col layout-col-primary">
          <section class="panel" id="section-remote">
            <div class="panel-header">
              <div class="panel-title-row">
                <div class="panel-title">Remote Firmware ¬∑ OTA Helper</div>
                <span class="panel-step">GitHub Releases</span>
              </div>
              <div class="badge" id="remoteRefreshBadge">GitHub ¬∑ Auto</div>
            </div>
            <div class="panel-body">
              <div class="panel-block">
                <div class="block-title">Repository</div>
                <div class="row">
                  <div>
                    <div class="label">Project</div>
                    <select id="projectSelect">
                      <option value="loading">Loading‚Ä¶</option>
                    </select>
                  </div>
                  <div style="flex:1;">
                    <div class="label">GitHub Repo (owner/repo)</div>
                    <input id="repoInput" type="text" class="mono" value="cifertech/ESP32-DIV" title="e.g. cifertech/RF-Clown" />
                  </div>
                  <button id="loadReleasesBtn" class="secondary btn-small" style="align-self:flex-end;">Refresh</button>
                </div>
              </div>
              <div class="panel-block">
                <div class="block-title">Releases</div>
                <div class="remote-search-row" aria-label="Remote releases search and filters">
                  <input id="projectSearch" type="text" placeholder="Search projects‚Ä¶" />
                  <input id="assetSearch" type="text" placeholder="Search assets or release tags‚Ä¶" class="mono" />
                  <label class="remote-toggle" title="Include prerelease versions from GitHub">
                    <input id="remoteShowPrereleases" type="checkbox" />
                    <span>Prereleases</span>
                  </label>
                  <label class="remote-toggle" title="Show all assets (not only flashable .bin files)">
                    <input id="remoteShowAllAssets" type="checkbox" />
                    <span>Show all assets</span>
                  </label>
                </div>
                <div id="projectCards" class="project-cards"></div>
                <div class="remote-meta" style="margin-top:8px;">
                  <div class="label" id="remoteAssetsLabel">Available .bin assets</div>
                  <div class="auto-refresh-status" id="remoteRefreshStatus">Auto refresh warming up‚Ä¶</div>
                </div>
                <ul id="githubList" class="github-list"></ul>
              </div>
              <div class="panel-block">
                <div class="block-title">Flash</div>
                <div class="label">Selected</div>
                <div class="value-soft mono" id="selectedRemote" style="margin-bottom:8px;">‚Äî</div>
                <div class="row" style="flex-wrap:wrap; gap:8px;">
                  <button id="flashRemoteBtn" class="btn-small">‚ö° Flash selected</button>
                  <button id="flashFullSetBtn" class="btn-small" title="Flash all .bin files in this release at standard addresses">üì¶ Flash full set</button>
                  <button id="openDownloadBtn" class="secondary btn-small">Open download</button>
                  <button id="copyOtaUrlBtn" class="secondary btn-small">Copy OTA URL</button>
                  <button id="viewChangelogBtn" class="secondary btn-small">üìã Changelog</button>
                </div>
                <div id="releaseSetPreview" class="release-set-preview"></div>
                <div class="hint" style="margin-top:6px;">Full set: bootloader‚Üí0x1000, partition‚Üí0x8000, app‚Üí0x10000.</div>
              </div>
              <div class="panel-block">
                <div class="block-title">Flash from URL</div>
                <div class="hint" style="margin-bottom:6px;">Use a direct .bin URL if GitHub is blocked (CORS).</div>
                <div class="row">
                  <input id="remoteUrlInput" type="text" class="mono" style="flex:1;" placeholder="https://.../firmware.bin" />
                  <button id="flashUrlBtn" class="btn-small">Flash URL</button>
                </div>
              </div>
              <div class="panel-block">
                <div class="block-title">History</div>
                <ul id="historyList" class="history-list"></ul>
              </div>
            </div>
          </section>
        </div>
        <div class="layout-col layout-col-secondary" id="flasher-log-host-remote"></div>
      </div>
    </div>

    <div id="tab-page-console" class="tab-page" role="tabpanel" aria-labelledby="main-tab-console">
      <section class="panel console-panel-full">
        <div class="panel-header">
          <div class="panel-title-row">
            <div class="panel-title">Serial Console</div>
            <span class="panel-step">Monitor ¬∑ Send</span>
          </div>
          <div class="badge">WebSerial</div>
        </div>
        <div class="panel-body">
          <div class="panel-block">
            <div class="block-title">Port</div>
            <div class="row">
              <button id="openConsoleBtn" class="secondary btn-small">üß™ Open port</button>
              <button id="closeConsoleBtn" class="secondary btn-small">Close</button>
              <select id="baudSelect" style="width:auto;">
                <option value="115200" selected>115200</option>
                <option value="921600">921600</option>
                <option value="74880">74880</option>
                <option value="57600">57600</option>
                <option value="38400">38400</option>
                <option value="19200">19200</option>
                <option value="9600">9600</option>
              </select>
            </div>
          </div>
          <div class="panel-block">
            <div class="block-title">Output</div>
            <pre id="consoleLog"></pre>
          </div>
          <div class="panel-block">
            <div class="block-title">Send command</div>
            <div class="console-input-row">
              <input id="consoleInput" type="text" placeholder="Type and press Send (adds newline)" />
              <button id="consoleSendBtn" class="btn-small">Send</button>
            </div>
            <div class="hint" style="margin-top:6px;">Console is separate from flashing. Reopen after flash to see firmware logs.</div>
          </div>
        </div>
      </section>
    </div>

    <div id="tab-page-stats" class="tab-page" role="tabpanel" aria-labelledby="main-tab-stats">
      <section class="panel stats-panel-full">
        <div class="panel-header">
          <div class="panel-title-row">
            <div class="panel-title">Flash statistics</div>
          </div>
          <button id="clearStatsBtn" class="secondary btn-small">Clear</button>
        </div>
        <div class="panel-body">
          <div class="stats-grid">
            <div class="stat-card">
              <div class="stat-value" id="statTotalFlashes">0</div>
              <div class="stat-label">Total Flashes</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="statSuccessRate">‚Äî</div>
              <div class="stat-label">Success Rate</div>
            </div>
            <div class="stat-card">
              <div class="stat-value" id="statLastFlash">‚Äî</div>
              <div class="stat-label">Last Flash</div>
            </div>
          </div>
        </div>
      </section>
    </div>
  </main>

  <footer class="shell-footer">
    FirmwareHub by CiferTech ¬∑ Built on WebSerial + esptool-js
  </footer>
</div>

<!-- Changelog Modal -->
<div id="changelogModal" class="changelog-modal" role="dialog" aria-modal="true" aria-labelledby="changelogTitle">
  <div class="changelog-content">
    <div class="changelog-header">
      <div class="changelog-title" id="changelogTitle">Release Notes</div>
      <button id="closeChangelogBtn" class="secondary btn-small" aria-label="Close changelog">‚úï Close</button>
    </div>
    <div class="changelog-body" id="changelogBody">
      <div class="value-soft">Loading...</div>
    </div>
  </div>
</div>

<!-- SCRIPT -->
<script type="module">
  import { ESPLoader, Transport } from "https://cdn.jsdelivr.net/npm/esptool-js@0.4.5/bundle.js";

  // Elements
  const connDot   = document.getElementById("connDot");
  const connLabel = document.getElementById("connLabel");
  const chipFamilyBadge = document.getElementById("chipFamilyBadge");
  const chipNameEl = document.getElementById("chipName");
  const flashIdEl = document.getElementById("flashId");
  const flashSizeEl = document.getElementById("flashSize");
  const macAddrEl = document.getElementById("macAddr");
  const statusDot = document.getElementById("statusDot");
  const statusText = document.getElementById("statusText");

  const dropzone = document.getElementById("dropzone");
  const firmwareInput = document.getElementById("firmwareInput");
  const filenameEl = document.getElementById("filename");
  const progressBar = document.getElementById("progressBar");
  const logEl = document.getElementById("log");
  const flashAddressInput = document.getElementById("flashAddressInput");
  const flashSizeSelect = document.getElementById("flashSizeSelect");
  const flashModeSelect = document.getElementById("flashModeSelect");
  const flashFreqSelect = document.getElementById("flashFreqSelect");
  const regionAddressInput = document.getElementById("regionAddressInput");
  const regionSizeInput = document.getElementById("regionSizeInput");
  const multiFileContainer = document.getElementById("multiFileContainer");
  const addMultiFileBtn = document.getElementById("addMultiFileBtn");
  const flashAllMultiBtn = document.getElementById("flashAllMultiBtn");

  const projectSelect = document.getElementById("projectSelect");
  const repoInput = document.getElementById("repoInput");
  const loadReleasesBtn = document.getElementById("loadReleasesBtn");
  const githubList = document.getElementById("githubList");
  const selectedRemoteEl = document.getElementById("selectedRemote");
  const historyList = document.getElementById("historyList");
  const remoteRefreshStatus = document.getElementById("remoteRefreshStatus");
  const remoteRefreshBadge = document.getElementById("remoteRefreshBadge");
  const remoteAssetsLabel = document.getElementById("remoteAssetsLabel");
  const openDownloadBtn = document.getElementById("openDownloadBtn");
  const copyOtaUrlBtn = document.getElementById("copyOtaUrlBtn");
  const remoteUrlInput = document.getElementById("remoteUrlInput");
  const flashUrlBtn = document.getElementById("flashUrlBtn");
  const projectSearch = document.getElementById("projectSearch");
  const assetSearch = document.getElementById("assetSearch");
  const remoteShowPrereleases = document.getElementById("remoteShowPrereleases");
  const remoteShowAllAssets = document.getElementById("remoteShowAllAssets");
  const projectCards = document.getElementById("projectCards");

  const submitProjectSelect = document.getElementById("submitProjectSelect");
  const submitProjectName = document.getElementById("submitProjectName");
  const submitChip = document.getElementById("submitChip");
  const submitFirmwareName = document.getElementById("submitFirmwareName");
  const submitFirmwareVersion = document.getElementById("submitFirmwareVersion");
  const submitFirmwareUrl = document.getElementById("submitFirmwareUrl");
  const submitFirmwareFile = document.getElementById("submitFirmwareFile");
  const submitFirmwareHash = document.getElementById("submitFirmwareHash");
  const submitRepoInput = document.getElementById("submitRepoInput");
  const buildIssueBtn = document.getElementById("buildIssueBtn");
  const issueLink = document.getElementById("issueLink");
  const copyIssueBtn = document.getElementById("copyIssueBtn");

  const viewChangelogBtn = document.getElementById("viewChangelogBtn");
  const changelogModal = document.getElementById("changelogModal");
  const closeChangelogBtn = document.getElementById("closeChangelogBtn");
  const changelogTitle = document.getElementById("changelogTitle");
  const changelogBody = document.getElementById("changelogBody");
  const clearStatsBtn = document.getElementById("clearStatsBtn");
  const statTotalFlashes = document.getElementById("statTotalFlashes");
  const statSuccessRate = document.getElementById("statSuccessRate");
  const statLastFlash = document.getElementById("statLastFlash");

  const consoleLog = document.getElementById("consoleLog");
  const consoleInput = document.getElementById("consoleInput");
  const baudSelect = document.getElementById("baudSelect");
  const themeToggleBtn = document.getElementById("themeToggle");
  const themeToggleIcon = document.getElementById("themeToggleIcon");

  const connectBtn = document.getElementById("connectBtn");
  const disconnectBtn = document.getElementById("disconnectBtn");
  const openConsoleBtn = document.getElementById("openConsoleBtn");
  const closeConsoleBtn = document.getElementById("closeConsoleBtn");

  // State
  let devicePort = null;
  let transport = null;
  let esploader = null;
  let firmwareBuffer = null;
  let firmwareName = null;

  let selectedRemoteAsset = null;
  let githubAssets = [];
  let githubReleaseGroups = [];
  let activeReleaseTag = null;
  let history = [];
  let projectCatalog = [];
  let activeProjectId = null;
  let submitFileMeta = null;
  let flashStats = { total: 0, success: 0, failures: 0, lastFlash: null };
  let releasesCache = {};
  const REMOTE_REFRESH_INTERVAL = 120000;
  let remoteRefreshTimer = null;
  let releasesLoading = false;
  if (remoteRefreshBadge) {
    const minutesLabel =
      Math.max(1, Math.round(REMOTE_REFRESH_INTERVAL / 60000)) + "m";
    remoteRefreshBadge.textContent = "GitHub Releases ¬∑ Auto " + minutesLabel;
  }

  let consolePort = null;
  let consoleReader = null;
  let consoleWriter = null;
  const THEME_KEY = "cifertech_flasher_theme";
  const CORS_PROXY_KEY = "cifertech_flasher_cors_proxy_enabled";
  let corsProxyPrompted = false;
  const corsProxyEnabled = (() => {
    try {
      return localStorage.getItem(CORS_PROXY_KEY) === "1";
    } catch (_) {
      return false;
    }
  })();

  function formatError(err) {
    try {
      if (!err) return "Unknown error";
      if (typeof err === "string") return err;
      const name = err.name || err.constructor?.name || "Error";
      const msg = err.message || String(err);
      return name + (msg && msg !== name ? ": " + msg : "");
    } catch (_) {
      return "Unknown error";
    }
  }

  /** Parse hex (0x...) or decimal string to number. */
  function parseHexOrDec(str) {
    const s = String(str || "").trim();
    if (!s) return 0;
    if (s.toLowerCase().startsWith("0x")) return parseInt(s, 16);
    return parseInt(s, 10);
  }

  function hintForError(err) {
    const name = err?.name || "";
    const msg = (err?.message || "").toLowerCase();

    // Common WebSerial errors / user actions
    if (name === "NotFoundError") return "No port selected (the chooser was closed).";
    if (name === "NotAllowedError") return "Permission denied. Click the address-bar serial icon to manage permissions and try again.";
    if (name === "SecurityError") return "WebSerial requires HTTPS or http://localhost (file:// won't work).";

    // Port state / contention
    if (name === "InvalidStateError") return "Port is already open. Close the serial console or any other app using the COM port and retry.";
    if (name === "NetworkError" && msg.includes("failed to open"))
      return "Failed to open the port. Another program may be using it (Arduino IDE, PuTTY, VS Code Serial Monitor). Close it and retry.";

    // ESP bootloader sync issues commonly surface as generic errors
    if (msg.includes("timed out") || msg.includes("timeout"))
      return "Timeout talking to the bootloader. Try holding BOOT while clicking Connect, or press RESET when prompted by your board.";

    return "";
  }

  function webSerialUsable() {
    if (!("serial" in navigator)) {
      return {
        ok: false,
        reason: "WebSerial not supported. Use Chrome/Edge on desktop.",
      };
    }
    if (!window.isSecureContext) {
      const origin = location.protocol === "file:" ? "file://" : location.origin;
      return {
        ok: false,
        reason:
          "WebSerial requires a secure context (HTTPS or http://localhost). Current origin: " +
          origin +
          ". If you opened this from disk, serve it via a local web server.",
      };
    }
    return { ok: true, reason: "" };
  }

  function portInfoString(port) {
    try {
      const info = port?.getInfo?.() || {};
      const vid = info.usbVendorId != null ? "0x" + info.usbVendorId.toString(16) : null;
      const pid = info.usbProductId != null ? "0x" + info.usbProductId.toString(16) : null;
      if (vid || pid) return " (VID " + (vid || "‚Äî") + ", PID " + (pid || "‚Äî") + ")";
      return "";
    } catch (_) {
      return "";
    }
  }

  function appendLog(msg) {
    const time = new Date().toLocaleTimeString();
    logEl.textContent += "[" + time + "] " + msg + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  function setStatus(text, mode = "normal") {
    statusText.textContent = text;
    statusDot.classList.remove("connected");
    if (mode === "connected") {
      statusDot.classList.add("connected");
    }
    if (mode === "error") {
      statusDot.style.background = "#f97373";
      statusDot.style.boxShadow = "0 0 8px #f97373";
    } else {
      statusDot.style.background = mode === "connected" ? "#22c55e" : "#f97316";
      statusDot.style.boxShadow =
        "0 0 8px " + (mode === "connected" ? "#22c55e" : "#f97316");
    }
  }

  function setConnectionUi(connected, chipFamily) {
    if (disconnectBtn) disconnectBtn.disabled = !connected;
    if (connected) {
      connDot.style.background = "#22c55e";
      connDot.style.boxShadow = "0 0 10px #22c55e";
      connLabel.textContent = "Connected ¬∑ " + (chipFamily || "ESP");
    } else {
      connDot.style.background = "#f97316";
      connDot.style.boxShadow = "0 0 10px #f97316";
      connLabel.textContent = "No device";
      chipFamilyBadge.textContent = "No chip";
      chipNameEl.textContent = "‚Äî";
      flashIdEl.textContent = "‚Äî";
      flashSizeEl.textContent = "‚Äî";
      macAddrEl.textContent = "‚Äî";
    }
  }

  function setProgress(p) {
    progressBar.style.width = p + "%";
  }

  async function fetchArrayBuffer(url, options = {}) {
    const res = await fetch(url, options);
    if (!res.ok) {
      throw new Error("Download failed: " + res.status + (res.statusText ? " " + res.statusText : ""));
    }
    return await res.arrayBuffer();
  }

  function looksLikeCorsOrNetworkFetchFailure(err) {
    const name = err?.name || "";
    const msg = (err?.message || "").toLowerCase();
    const s = String(err || "").toLowerCase();
    // Browser fetch failures (often CORS blocked) surface as TypeError with "Failed to fetch"
    if (name === "TypeError" && (msg.includes("failed to fetch") || s.includes("failed to fetch"))) return true;
    if (s.includes("cors")) return true;
    return false;
  }

  function buildCorsProxyUrls(targetUrl) {
    const u = encodeURIComponent(targetUrl);
    return [
      // These are public third‚Äëparty proxies; use only if the user explicitly opts in.
      "https://corsproxy.io/?" + u,
      "https://api.allorigins.win/raw?url=" + u,
      "https://cors.isomorphic-git.org/" + targetUrl,
    ];
  }

  async function downloadRemoteFirmware(asset) {
    // Try direct browser_download_url first (fast path)
    try {
      return await fetchArrayBuffer(asset.url, { cache: "no-store" });
    } catch (e1) {
      const msg1 = formatError(e1);
      appendLog("Remote download (direct) failed: " + msg1);

      // Retry via GitHub API asset URL (sometimes behaves differently with redirects)
      if (asset.apiUrl) {
        try {
          return await fetchArrayBuffer(asset.apiUrl, {
            cache: "no-store",
            headers: {
              Accept: "application/octet-stream",
            },
          });
        } catch (e2) {
          const msg2 = formatError(e2);
          appendLog("Remote download (GitHub API) failed: " + msg2);
        }
      }

      // If it looks like CORS, optionally try a proxy (opt-in + remembered).
      const isCorsLike = looksLikeCorsOrNetworkFetchFailure(e1);
      const isFileOrigin = location.protocol === "file:";
      let allowProxy = corsProxyEnabled;

      if (!allowProxy && isCorsLike && !corsProxyPrompted) {
        corsProxyPrompted = true;
        const ok = confirm(
          "Your browser blocked downloading the GitHub release asset (likely CORS/redirect).\n\n" +
            "Allow using a public CORS proxy to download the .bin for flashing?\n" +
            "This sends the download URL through a third-party service. (Recommended only for trusted firmware.)"
        );
        if (ok) {
          allowProxy = true;
          try {
            localStorage.setItem(CORS_PROXY_KEY, "1");
          } catch (_) {}
          appendLog("CORS proxy enabled for remote downloads.");
        }
      }

      if (allowProxy && isCorsLike) {
        const candidates = buildCorsProxyUrls(asset.url);
        for (const proxyUrl of candidates) {
          try {
            appendLog("Trying CORS proxy‚Ä¶");
            return await fetchArrayBuffer(proxyUrl, { cache: "no-store" });
          } catch (e3) {
            appendLog("CORS proxy failed: " + formatError(e3));
          }
        }
      }

      if (isCorsLike) {
        appendLog(
          "Hint: Your browser blocked the GitHub release download (CORS/redirect). " +
            (isFileOrigin
              ? "If you're running from file://, serve this page from http://localhost or GitHub Pages. "
              : "") +
            "Use 'Copy OTA URL' to download the .bin manually, then flash it via Local Firmware."
        );
      }
      throw e1;
    }
  }

  async function safeClosePort(port) {
    try {
      if (port && port.readable) {
        await port.close();
      }
    } catch (_) {}
  }

  async function cleanupDeviceConnection({ statusTextOverride } = {}) {
    try {
      if (transport) await transport.disconnect();
    } catch (_) {}
    await safeClosePort(devicePort);

    devicePort = null;
    transport = null;
    esploader = null;

    setConnectionUi(false);
    setStatus(statusTextOverride || "Disconnected");
  }

  function addHistoryEntry(entry) {
    history.unshift({
      ...entry,
      ts: new Date().toISOString(),
    });
    history = history.slice(0, 15);
    localStorage.setItem("cifertech_flasher_history", JSON.stringify(history));
    renderHistory();
  }

  function renderHistory() {
    historyList.innerHTML = "";
    if (!history.length) {
      const li = document.createElement("li");
      li.className = "history-item";
      li.innerHTML = "<span>No history yet</span>";
      historyList.appendChild(li);
      return;
    }
    history.forEach((h) => {
      const li = document.createElement("li");
      li.className = "history-item";
      const left = document.createElement("span");
      left.textContent = h.name;
      const right = document.createElement("span");
      right.className = "label-chip";
      right.textContent = h.type;
      li.appendChild(left);
      li.appendChild(right);
      historyList.appendChild(li);
    });
  }

  function loadHistoryFromStorage() {
    try {
      const raw = localStorage.getItem("cifertech_flasher_history");
      if (raw) history = JSON.parse(raw);
    } catch (e) {
      history = [];
    }
    renderHistory();
  }

  function loadFlashStats() {
    try {
      const raw = localStorage.getItem("cifertech_flasher_stats");
      if (raw) flashStats = JSON.parse(raw);
    } catch (e) {
      flashStats = { total: 0, success: 0, failures: 0, lastFlash: null };
    }
    updateStats();
  }

  function saveFlashStats() {
    try {
      localStorage.setItem("cifertech_flasher_stats", JSON.stringify(flashStats));
    } catch (e) {}
  }

  function recordFlashAttempt(success) {
    flashStats.total++;
    if (success) {
      flashStats.success++;
    } else {
      flashStats.failures++;
    }
    flashStats.lastFlash = new Date().toISOString();
    saveFlashStats();
    updateStats();
  }

  function updateStats() {
    if (statTotalFlashes) {
      statTotalFlashes.textContent = flashStats.total || 0;
    }
    if (statSuccessRate) {
      if (flashStats.total > 0) {
        const rate = Math.round((flashStats.success / flashStats.total) * 100);
        statSuccessRate.textContent = rate + "%";
      } else {
        statSuccessRate.textContent = "‚Äî";
      }
    }
    if (statLastFlash) {
      if (flashStats.lastFlash) {
        const date = new Date(flashStats.lastFlash);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);
        
        if (diffMins < 1) {
          statLastFlash.textContent = "Just now";
        } else if (diffMins < 60) {
          statLastFlash.textContent = diffMins + "m ago";
        } else if (diffHours < 24) {
          statLastFlash.textContent = diffHours + "h ago";
        } else {
          statLastFlash.textContent = diffDays + "d ago";
        }
      } else {
        statLastFlash.textContent = "‚Äî";
      }
    }
  }

  loadHistoryFromStorage();
  loadFlashStats();

  if (multiFileContainer) addMultiFileRow("0x0");

  const fallbackProjects = [
    {
      id: "esp32-div",
      name: "ESP32-DIV",
      repo: "cifertech/ESP32-DIV",
      chipFamily: "ESP32",
      description: "Multi-tool ESP32 device with RF + WiFi features.",
      tags: ["esp32", "rf", "wifi"],
      assetFilter: ".bin",
    },
    {
      id: "nrfbox",
      name: "nRFBox",
      repo: "cifertech/nRFBox",
      chipFamily: "ESP32",
      description: "Wireless toolbox with NRF + ESP32 firmware.",
      tags: ["esp32", "nrf", "wireless"],
      assetFilter: ".bin",
    },
    {
      id: "rf-clown",
      name: "RF-Clown",
      repo: "cifertech/RF-Clown",
      chipFamily: "ESP32",
      description: "RF experimentation device for CiferTech.",
      tags: ["esp32", "rf"],
      assetFilter: ".bin",
    },
  ];

  function normalizeSearchText(value) {
    return (value || "").toLowerCase().trim();
  }

  function getActiveProject() {
    if (!projectCatalog.length) return null;
    if (activeProjectId) {
      return projectCatalog.find((p) => p.id === activeProjectId) || null;
    }
    const repo = (repoInput?.value || "").trim();
    if (repo) {
      return projectCatalog.find((p) => p.repo === repo) || null;
    }
    return null;
  }

  function assetMatches(name, project) {
    const lower = String(name || "").toLowerCase();
    let filters = [];
    if (project && project.assetFilter) {
      filters = Array.isArray(project.assetFilter)
        ? project.assetFilter
        : [project.assetFilter];
    }
    if (!filters.length) {
      return lower.endsWith(".bin");
    }
    return filters.some((f) => lower.endsWith(String(f).toLowerCase()));
  }

  function renderProjectSelect(selectEl, { includeCustom = true } = {}) {
    if (!selectEl) return;
    selectEl.innerHTML = "";
    if (!projectCatalog.length) {
      const opt = document.createElement("option");
      opt.value = "none";
      opt.textContent = "No projects";
      selectEl.appendChild(opt);
      return;
    }
    projectCatalog.forEach((project) => {
      const opt = document.createElement("option");
      opt.value = project.id;
      opt.textContent = project.name;
      selectEl.appendChild(opt);
    });
    if (includeCustom) {
      const custom = document.createElement("option");
      custom.value = "custom";
      custom.textContent = "Custom‚Ä¶";
      selectEl.appendChild(custom);
    }
  }

  function setActiveProject(project, { trigger = "auto", silent = false } = {}) {
    if (!project) return;
    activeProjectId = project.id;
    if (projectSelect) {
      projectSelect.value = project.id;
    }
    if (repoInput) {
      repoInput.value = project.repo;
    }
    if (submitProjectSelect) {
      submitProjectSelect.value = project.id;
    }
    if (submitProjectName) {
      submitProjectName.value = project.name;
    }
    if (submitChip && !submitChip.value) {
      submitChip.value = project.chipFamily || "";
    }
    renderProjectCards();
    if (!silent) {
      handleRepoChange({ silent: false, trigger });
    }
  }

  function renderProjectCards() {
    if (!projectCards) return;
    projectCards.innerHTML = "";
    const query = normalizeSearchText(projectSearch?.value);

    const filtered = projectCatalog.filter((p) => {
      if (!query) return true;
      const hay = [
        p.name,
        p.repo,
        p.description,
        ...(p.tags || []),
        p.chipFamily,
      ]
        .join(" ")
        .toLowerCase();
      return hay.includes(query);
    });

    if (!filtered.length) {
      const empty = document.createElement("div");
      empty.className = "value-soft";
      empty.textContent = "No projects match your search.";
      projectCards.appendChild(empty);
      return;
    }

    filtered.forEach((project) => {
      const card = document.createElement("div");
      card.className = "project-card";
      if (project.id === activeProjectId) {
        card.classList.add("active");
      }

      const title = document.createElement("div");
      title.className = "project-card-title";
      title.textContent = project.name;
      const desc = document.createElement("div");
      desc.className = "project-card-desc";
      desc.textContent = project.description || project.repo;
      const tags = document.createElement("div");
      tags.className = "project-card-tags";
      (project.tags || []).forEach((t) => {
        const tag = document.createElement("span");
        tag.className = "project-card-tag";
        tag.textContent = t;
        tags.appendChild(tag);
      });

      card.appendChild(title);
      card.appendChild(desc);
      card.appendChild(tags);
      card.addEventListener("click", () => {
        setActiveProject(project, { trigger: "card", silent: false });
      });
      projectCards.appendChild(card);
    });
  }

  function applyProjectCatalog(projects) {
    projectCatalog = Array.isArray(projects) ? projects : [];
    renderProjectSelect(projectSelect, { includeCustom: true });
    renderProjectSelect(submitProjectSelect, { includeCustom: true });

    const repo = (repoInput?.value || "").trim();
    const match = projectCatalog.find((p) => p.repo === repo) || projectCatalog[0];
    if (match) {
      setActiveProject(match, { trigger: "init", silent: true });
    }
    renderProjectCards();
  }

  async function loadProjectCatalog() {
    try {
      const res = await fetch("projects.json", { cache: "no-store" });
      if (!res.ok) throw new Error("Projects catalog fetch failed");
      const data = await res.json();
      applyProjectCatalog(data);
    } catch (e) {
      console.warn("Using fallback project catalog:", e);
      applyProjectCatalog(fallbackProjects);
    }
  }

  function setRemoteRefreshStatus(text) {
    if (remoteRefreshStatus) {
      remoteRefreshStatus.textContent = text;
    }
  }

  function highlightGithubSelection(target) {
    if (!githubList) return;
    Array.from(githubList.querySelectorAll(".github-item")).forEach((item) => {
      item.style.borderColor = "var(--border)";
      item.style.borderLeftColor = "transparent";
    });
    if (target) {
      target.style.borderColor = "rgba(249,115,22,0.4)";
      target.style.borderLeftColor = "var(--accent)";
    }
  }

  function selectRemoteAsset(asset, listItem) {
    if (asset) {
      selectedRemoteEl.textContent =
        asset.name + " (" + (asset.releaseTag || "release") + ")";
    } else {
      selectedRemoteEl.textContent = "‚Äî";
    }
    selectedRemoteAsset = asset || null;
    if (asset && asset.releaseTag) {
      activeReleaseTag = asset.releaseTag;
    }
    highlightGithubSelection(listItem);
    updateReleaseSetPreview();
    updateRemoteActionsUi();
  }

  /** Suggest flash address from filename (bootloader, partition, app). */
  function suggestAddressForAsset(name) {
    const n = (name || "").toLowerCase();
    if (n.includes("bootloader")) return 0x1000;
    if (n.includes("partition")) return 0x8000;
    return 0x10000;
  }

  function getAssetsInRelease(releaseTag) {
    if (!releaseTag) return [];
    return githubAssets.filter((a) => a.releaseTag === releaseTag);
  }

  function updateReleaseSetPreview() {
    const el = document.getElementById("releaseSetPreview");
    if (!el) return;
    const releaseTag =
      activeReleaseTag ||
      selectedRemoteAsset?.releaseTag ||
      (githubAssets[0] && githubAssets[0].releaseTag);
    const assets = getAssetsInRelease(releaseTag);
    if (!assets.length) {
      el.innerHTML = "";
      return;
    }
    const sorted = [...assets].sort((a, b) => suggestAddressForAsset(a.name) - suggestAddressForAsset(b.name));
    el.innerHTML = sorted
      .map(
        (a) =>
          '<div class="preview-row"><span class="preview-addr">0x' +
          suggestAddressForAsset(a.name).toString(16) +
          "</span> " +
          escapeHtml(a.name) +
          "</div>"
      )
      .join("");
  }

  function updateRemoteActionsUi() {
    const selected = !!selectedRemoteAsset;
    const releaseTag =
      activeReleaseTag ||
      selectedRemoteAsset?.releaseTag ||
      (githubAssets[0] && githubAssets[0].releaseTag) ||
      null;
    const releaseAssets = releaseTag ? getAssetsInRelease(releaseTag) : [];

    const flashRemoteBtn = document.getElementById("flashRemoteBtn");
    const flashFullSetBtn = document.getElementById("flashFullSetBtn");
    if (flashRemoteBtn) flashRemoteBtn.disabled = !selected;
    if (openDownloadBtn) openDownloadBtn.disabled = !selected;
    if (copyOtaUrlBtn) copyOtaUrlBtn.disabled = !selected;
    if (flashFullSetBtn) flashFullSetBtn.disabled = !releaseTag || !releaseAssets.length;

    const repo = (repoInput?.value || "").trim();
    if (viewChangelogBtn) viewChangelogBtn.disabled = !repo || !releasesCache[repo];
  }

  function getCurrentFlashOptionsSummary() {
    const address = parseHexOrDec(flashAddressInput?.value || "0");
    const flashSize = flashSizeSelect?.value || "keep";
    const flashMode = flashModeSelect?.value || "keep";
    const flashFreq = flashFreqSelect?.value || "keep";
    return {
      address,
      flashSize,
      flashMode,
      flashFreq,
      summary:
        "Options: address 0x" +
        address.toString(16) +
        ", size " +
        flashSize +
        ", mode " +
        flashMode +
        ", freq " +
        flashFreq,
    };
  }

  function buildWritePlanSelected(asset) {
    if (!asset) return { title: "Flash selected", lines: [], warnings: [] };
    const repo = (repoInput?.value || "").trim();
    const opt = getCurrentFlashOptionsSummary();
    const warnings = [];
    const n = (asset.name || "").toLowerCase();
    if (n.includes("bootloader") || n.includes("partition")) {
      warnings.push(
        "Selected file looks like a component (bootloader/partition). Flashing it alone may break a device unless you intend to."
      );
    }
    return {
      title: "Flash selected firmware?",
      lines: [
        "Repo: " + (repo || "‚Äî"),
        "Release: " + (asset.releaseTag || "‚Äî"),
        "File: " + asset.name,
        opt.summary,
        "",
        "This will download the file and flash it as a single image at the address above.",
      ],
      warnings,
    };
  }

  function buildWritePlanFullSet(releaseTag) {
    const repo = (repoInput?.value || "").trim();
    const assets = getAssetsInRelease(releaseTag);
    const warnings = [];

    const expected = {
      bootloader: assets.some((a) => (a.name || "").toLowerCase().includes("bootloader")),
      partition: assets.some((a) => (a.name || "").toLowerCase().includes("partition")),
      app: assets.length > 0,
    };

    if (!expected.bootloader || !expected.partition) {
      warnings.push(
        "This release does not include obvious bootloader/partition files. Addresses are inferred from filenames; double-check before proceeding."
      );
    }

    const byAddr = new Map();
    assets.forEach((a) => {
      const addr = suggestAddressForAsset(a.name);
      const key = "0x" + addr.toString(16);
      const arr = byAddr.get(key) || [];
      arr.push(a.name);
      byAddr.set(key, arr);
    });
    Array.from(byAddr.entries()).forEach(([addr, names]) => {
      if (names.length > 1) {
        warnings.push("Multiple files map to " + addr + ": " + names.join(", "));
      }
    });

    const sorted = [...assets].sort((a, b) => suggestAddressForAsset(a.name) - suggestAddressForAsset(b.name));
    const lines = [
      "Repo: " + (repo || "‚Äî"),
      "Release: " + (releaseTag || "‚Äî"),
      "",
      "Will flash " + sorted.length + " file(s):",
      ...sorted.map(
        (a) =>
          "  - 0x" + suggestAddressForAsset(a.name).toString(16) + "  " + a.name
      ),
      "",
      "This will download all files above, then write them to flash at the shown addresses.",
    ];
    return { title: "Flash full set?", lines, warnings };
  }

  function confirmWritePlan(plan) {
    const warnings = (plan.warnings || []).filter(Boolean);
    const msg =
      (plan.title || "Confirm") +
      "\n\n" +
      (plan.lines || []).join("\n") +
      (warnings.length ? "\n\nWarnings:\n- " + warnings.join("\n- ") : "") +
      "\n\nProceed?";
    return confirm(msg);
  }

  function escapeHtml(s) {
    const div = document.createElement("div");
    div.textContent = s;
    return div.innerHTML;
  }

  function startRemoteAutoRefresh() {
    if (remoteRefreshTimer) clearInterval(remoteRefreshTimer);
    remoteRefreshTimer = setInterval(() => {
      if (document.hidden) return;
      loadGitHubReleases({ silent: true, trigger: "auto" });
    }, REMOTE_REFRESH_INTERVAL);
  }

  function formatDateShort(iso) {
    try {
      if (!iso) return "";
      return new Date(iso).toLocaleDateString();
    } catch (_) {
      return "";
    }
  }

  function getReleaseAssetsForUi(group, { showAllAssets = false, query = "" } = {}) {
    const q = normalizeSearchText(query);
    const base = showAllAssets ? (group.assetsAll || []) : (group.assetsFlashable || []);
    if (!q) return base;
    const relHay = [group.tag, group.name || ""].join(" ").toLowerCase();
    return base.filter((a) => {
      const hay = (a.name + " " + relHay).toLowerCase();
      return hay.includes(q);
    });
  }

  function renderRemoteReleaseGroups({ query } = {}) {
    if (!githubList) return;
    const q = query != null ? String(query) : (assetSearch?.value || "");
    const showPre = !!remoteShowPrereleases?.checked;
    const showAll = !!remoteShowAllAssets?.checked;

    githubList.innerHTML = "";

    const groups = (githubReleaseGroups || [])
      .filter((g) => (showPre ? true : !g.prerelease))
      .map((g) => ({ ...g, _assetsToRender: getReleaseAssetsForUi(g, { showAllAssets: showAll, query: q }) }))
      .filter((g) => g._assetsToRender.length > 0);

    if (!groups.length) {
      const li = document.createElement("li");
      li.className = "github-item";
      li.innerHTML = "<span>No assets match your filters.</span>";
      githubList.appendChild(li);
      highlightGithubSelection(null);
      return;
    }

    if (activeReleaseTag && !groups.some((g) => g.tag === activeReleaseTag)) {
      activeReleaseTag = groups[0].tag;
    }

    groups.forEach((g, idx) => {
      const li = document.createElement("li");
      li.className = "release-group";

      const details = document.createElement("details");
      details.className = "release-details";
      details.open = activeReleaseTag ? g.tag === activeReleaseTag : idx === 0;

      const summary = document.createElement("summary");
      summary.className = "release-summary";
      summary.addEventListener("click", () => {
        activeReleaseTag = g.tag;
        updateReleaseSetPreview();
        updateRemoteActionsUi();
      });

      const main = document.createElement("div");
      main.className = "release-summary-main";

      const title = document.createElement("div");
      title.className = "release-title";
      title.textContent = g.tag || "release";

      const sub = document.createElement("div");
      sub.className = "release-subtitle";
      sub.textContent = g.name || "";

      main.appendChild(title);
      if (g.name) main.appendChild(sub);

      const meta = document.createElement("div");
      meta.className = "release-summary-meta";

      if (g.prerelease) {
        const pre = document.createElement("span");
        pre.className = "release-badge prerelease";
        pre.textContent = "prerelease";
        meta.appendChild(pre);
      }

      const date = formatDateShort(g.publishedAt);
      if (date) {
        const d = document.createElement("span");
        d.className = "release-badge";
        d.textContent = date;
        meta.appendChild(d);
      }

      const count = document.createElement("span");
      count.className = "release-badge";
      count.textContent = g._assetsToRender.length + " asset" + (g._assetsToRender.length === 1 ? "" : "s");
      meta.appendChild(count);

      summary.appendChild(main);
      summary.appendChild(meta);
      details.appendChild(summary);

      const assetsUl = document.createElement("ul");
      assetsUl.className = "release-assets";

      g._assetsToRender.forEach((a) => {
        const item = document.createElement("li");
        item.className = "github-item";
        item.dataset.assetId = a.id != null ? String(a.id) : "";
        item.dataset.releaseTag = g.tag || "";

        const left = document.createElement("span");
        left.textContent = a.name;

        const right = document.createElement("span");
        right.className = "github-item-right";

        if (a.flashable) {
          const addr = document.createElement("span");
          addr.className = "label-chip mono";
          addr.textContent = "0x" + suggestAddressForAsset(a.name).toString(16);
          right.appendChild(addr);
        } else {
          item.setAttribute("aria-disabled", "true");
          const badge = document.createElement("span");
          badge.className = "label-chip";
          badge.textContent = "not flashable";
          right.appendChild(badge);
        }

        item.appendChild(left);
        item.appendChild(right);

        if (a.flashable) {
          item.onclick = () => {
            activeReleaseTag = g.tag;
            selectRemoteAsset(a, item);
          };
        } else {
          item.onclick = () => {
            alert("That asset is not a flashable firmware file. Select a .bin asset instead.");
          };
        }
        assetsUl.appendChild(item);
      });

      details.appendChild(assetsUl);
      li.appendChild(details);
      githubList.appendChild(li);
    });

    // If we have a selected asset, re-apply highlight to its rendered item.
    if (selectedRemoteAsset && selectedRemoteAsset.id != null) {
      const el = githubList.querySelector(
        '.github-item[data-asset-id="' + String(selectedRemoteAsset.id) + '"]'
      );
      if (el) highlightGithubSelection(el);
    }
  }

  function applyTheme(theme) {
    const nextTheme = theme === "light" ? "light" : "dark";
    document.body.dataset.theme = nextTheme;
    const icon = nextTheme === "light" ? "üåô" : "‚òÄÔ∏è";
    const label =
      nextTheme === "light" ? "Switch to dark mode" : "Switch to light mode";
    themeToggleIcon.textContent = icon;
    themeToggleBtn.setAttribute("aria-label", label);
    themeToggleBtn.setAttribute("title", label);
    try {
      localStorage.setItem(THEME_KEY, nextTheme);
    } catch (_) {}
  }

  const storedTheme = (() => {
    try {
      return localStorage.getItem(THEME_KEY);
    } catch (_) {
      return null;
    }
  })();
  const prefersLight = window.matchMedia
    ? window.matchMedia("(prefers-color-scheme: light)").matches
    : false;
  applyTheme(storedTheme || (prefersLight ? "light" : "dark"));

  themeToggleBtn.addEventListener("click", () => {
    const current = document.body.dataset.theme || "dark";
    applyTheme(current === "dark" ? "light" : "dark");
  });

  // Main tabs: Connect | Local Flash | Remote Flash | Console | Statistics
  const mainTabs = document.querySelectorAll(".main-tabs [role=\"tab\"]");
  const tabPages = document.querySelectorAll(".tab-page");
  const flasherLogPanel = document.getElementById("flasher-log-panel");
  const flasherLogHostConnect = document.getElementById("flasher-log-host-connect");
  const flasherLogHostLocal = document.getElementById("flasher-log-host-local");
  const flasherLogHostRemote = document.getElementById("flasher-log-host-remote");

  function moveFlasherLogTo(tabId) {
    if (!flasherLogPanel) return;
    const host =
      tabId === "connect" ? flasherLogHostConnect
      : tabId === "local" ? flasherLogHostLocal
      : tabId === "remote" ? flasherLogHostRemote
      : null;
    if (host) host.appendChild(flasherLogPanel);
  }

  mainTabs.forEach((tab) => {
    tab.addEventListener("click", () => {
      const id = tab.getAttribute("data-tab");
      mainTabs.forEach((t) => t.setAttribute("aria-selected", t === tab ? "true" : "false"));
      tabPages.forEach((p) => {
        const show = p.id === "tab-page-" + id;
        p.classList.toggle("active", show);
      });
      if (id === "connect" || id === "local" || id === "remote") moveFlasherLogTo(id);
    });
  });

  async function loadGitHubReleases({ silent = false, trigger = "manual" } = {}) {
    const repo = repoInput.value.trim();
    if (!repo || !repo.includes("/")) {
      if (!silent) {
        alert("Repo format should be owner/repo, e.g. cifertech/RF-Clown");
      }
      setRemoteRefreshStatus("Invalid repo format");
      return false;
    }

    if (releasesLoading) {
      setRemoteRefreshStatus("Refresh already running‚Ä¶");
      return false;
    }

    releasesLoading = true;

    if (!silent && loadReleasesBtn) {
      loadReleasesBtn.disabled = true;
      loadReleasesBtn.textContent = "Refreshing‚Ä¶";
    }

    const previousSelectionId = selectedRemoteAsset?.id ?? null;
    const previousSelectionUrl = selectedRemoteAsset?.url ?? null;
    const previousSelectionName = selectedRemoteAsset?.name ?? null;
    const previousSelectionRelease = selectedRemoteAsset?.releaseTag ?? null;
    setRemoteRefreshStatus("Refreshing‚Ä¶");

    try {
      const url = "https://api.github.com/repos/" + repo + "/releases";
      const res = await fetch(url);
      if (!res.ok) throw new Error("GitHub API: " + res.status);
      const releases = await res.json();
      
      // Cache releases for changelog
      releasesCache[repo] = releases;

      const activeProject = getActiveProject();
      githubReleaseGroups = (releases || []).map((rel) => {
        const tag = rel.tag_name || rel.name || "release";
        const assetsAll = (rel.assets || [])
          .filter((a) => a && a.name)
          .map((asset) => {
            const flashable = assetMatches(asset.name, activeProject);
            return {
              releaseTag: tag,
              name: asset.name,
              url: asset.browser_download_url,
              apiUrl: asset.url,
              id: asset.id,
              flashable,
            };
          });
        const assetsFlashable = assetsAll.filter((a) => a.flashable);
        return {
          tag,
          name: rel.name || "",
          publishedAt: rel.published_at || "",
          prerelease: !!rel.prerelease,
          assetsAll,
          assetsFlashable,
        };
      });

      githubAssets = githubReleaseGroups.flatMap((g) => g.assetsFlashable || []);
      if (remoteAssetsLabel) {
        remoteAssetsLabel.textContent =
          "Flashable firmware assets: " +
          githubAssets.length +
          (githubAssets.length === 1 ? "" : "");
      }

      // Keep/restore selection if possible.
      const preferred = (() => {
        if (previousSelectionId != null) {
          const a = githubAssets.find((x) => x.id === previousSelectionId);
          if (a) return a;
        }
        if (previousSelectionUrl) {
          const a = githubAssets.find((x) => x.url === previousSelectionUrl);
          if (a) return a;
        }
        if (previousSelectionName && previousSelectionRelease) {
          const a = githubAssets.find((x) => x.name === previousSelectionName && x.releaseTag === previousSelectionRelease);
          if (a) return a;
        }
        if (previousSelectionName) {
          const a = githubAssets.find((x) => x.name === previousSelectionName);
          if (a) return a;
        }
        return githubAssets[0] || null;
      })();

      if (!activeReleaseTag) {
        activeReleaseTag = preferred?.releaseTag || (githubAssets[0] && githubAssets[0].releaseTag) || null;
      } else {
        const stillExists = githubReleaseGroups.some((g) => g.tag === activeReleaseTag);
        if (!stillExists) activeReleaseTag = preferred?.releaseTag || null;
      }

      renderRemoteReleaseGroups();

      if (preferred) {
        const el = githubList?.querySelector(
          '.github-item[data-asset-id="' + String(preferred.id) + '"]'
        );
        selectRemoteAsset(preferred, el || null);
      } else {
        selectRemoteAsset(null, null);
        setRemoteRefreshStatus("No .bin assets");
        return true;
      }

      const label = trigger === "auto" ? "Auto refreshed" : "Updated";
      setRemoteRefreshStatus(label + " " + new Date().toLocaleTimeString());
      return true;
    } catch (e) {
      console.error(e);
      githubList.innerHTML = "";
      const li = document.createElement("li");
      li.className = "github-item";
      li.innerHTML = "<span>Error loading releases.</span>";
      githubList.appendChild(li);
      githubReleaseGroups = [];
      githubAssets = [];
      activeReleaseTag = null;
      if (remoteAssetsLabel) remoteAssetsLabel.textContent = "Available .bin assets";
      if (!silent) {
        alert("Error loading releases.");
      }
      setRemoteRefreshStatus("Refresh failed");
      return false;
    } finally {
      if (!silent && loadReleasesBtn) {
        loadReleasesBtn.disabled = false;
        loadReleasesBtn.textContent = "Refresh";
      }
      releasesLoading = false;
    }
  }

  function handleRepoChange({ silent = false, trigger = "manual" } = {}) {
    loadGitHubReleases({ silent, trigger }).then((success) => {
      if (success) startRemoteAutoRefresh();
    });
  }

  // project selector (RF-Clown, ESP32-DIV, nRFBox, custom)
  projectSelect.addEventListener("change", () => {
    const v = projectSelect.value;
    if (v !== "custom") {
      const project = projectCatalog.find((p) => p.id === v);
      if (project) {
        setActiveProject(project, { trigger: "select", silent: false });
      }
    } else {
      repoInput.focus();
    }
  });

  repoInput.addEventListener("change", () => {
    handleRepoChange({ silent: false, trigger: "repo-input" });
  });

  if (loadReleasesBtn) {
    loadReleasesBtn.addEventListener("click", () => {
      handleRepoChange({ silent: false, trigger: "manual" });
    });
  }

  loadProjectCatalog().then(() => {
    handleRepoChange({ silent: true, trigger: "init" });
  });

  document.addEventListener("visibilitychange", () => {
    if (!document.hidden) {
      loadGitHubReleases({ silent: true, trigger: "visibility" });
    }
  });

  // ========= CONNECTION & INFO =========
  connectBtn.onclick = async () => {
    let port = null;
    try {
      const usable = webSerialUsable();
      if (!usable.ok) {
        alert(usable.reason);
        setStatus("WebSerial unavailable", "error");
        appendLog(usable.reason);
        return;
      }

      // Avoid "port already open" by closing the console first.
      if (consolePort) {
        appendLog("Closing serial console to free the port‚Ä¶");
        await closeConsole();
      }

      // If already connected, clean up first to avoid invalid state.
      if (devicePort || transport || esploader) {
        appendLog("Cleaning up previous connection‚Ä¶");
        await cleanupDeviceConnection({ statusTextOverride: "Reconnecting‚Ä¶" });
      }

      setStatus("Requesting port‚Ä¶");
      port = await navigator.serial.requestPort();
      appendLog("Port selected" + portInfoString(port));

      devicePort = port;
      transport = new Transport(port);
      esploader = new ESPLoader({
        transport,
        baudrate: 115200,
        romBaudrate: 115200,
        enableTracing: false,
      });

      appendLog("Connecting to chip‚Ä¶");
      setStatus("Connecting‚Ä¶");

      await esploader.main();        // bootloader + stub
      await esploader.flashId();     // probe flash

      const chipFamily = esploader.chip.CHIP_NAME || "ESP";
      chipFamilyBadge.textContent = chipFamily;

      setConnectionUi(true, chipFamily);
      setStatus("Connected (" + chipFamily + ")", "connected");
      appendLog("Connected ¬∑ Chip: " + chipFamily);

      // Flash info
      try {
        const id = await esploader.flashId();
        flashIdEl.textContent = "0x" + id.toString(16);
      } catch (e) {
        flashIdEl.textContent = "Unknown";
      }

      try {
        await esploader.detectFlashSize();
        const sizeBytes = await esploader.flashSizeBytes();
        const sizeMb = (sizeBytes / (1024 * 1024)).toFixed(1);
        flashSizeEl.textContent = sizeMb + " MB";
      } catch (e) {
        flashSizeEl.textContent = "detect";
      }

      try {
        const mac = await esploader.chip.get_efuse_mac(esploader);
        macAddrEl.textContent = mac || "‚Äî";
      } catch (e) {
        macAddrEl.textContent = "‚Äî";
      }

      chipNameEl.textContent = chipFamily;

    } catch (err) {
      console.error(err);
      const msg = formatError(err);
      const hint = hintForError(err);
      appendLog("Error while connecting: " + msg);
      if (hint) appendLog("Hint: " + hint);
      setStatus("Connect failed", "error");
      setConnectionUi(false);
      try {
        await safeClosePort(devicePort || port);
      } catch (_) {}
      devicePort = null;
      transport = null;
      esploader = null;
    }
  };

  disconnectBtn.onclick = async () => {
    try {
      if (transport) {
        await transport.disconnect();
      }
      if (devicePort && devicePort.readable) {
        await devicePort.close();
      }
    } catch (e) {}
    devicePort = null;
    transport = null;
    esploader = null;
    setConnectionUi(false);
    setStatus("Disconnected");
    appendLog("Disconnected.");
  };

  // ========= LOCAL FILE HANDLING =========
  dropzone.onclick = () => firmwareInput.click();

  dropzone.addEventListener("dragover", (e) => {
    e.preventDefault();
    dropzone.style.borderColor = "#fb923c";
  });
  dropzone.addEventListener("dragleave", () => {
    dropzone.style.borderColor = "rgba(148,163,184,0.6)";
  });
  dropzone.addEventListener("drop", async (e) => {
    e.preventDefault();
    dropzone.style.borderColor = "rgba(148,163,184,0.6)";
    const file = e.dataTransfer.files[0];
    if (!file) return;
    await handleFirmwareFile(file);
  });

  firmwareInput.onchange = async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    await handleFirmwareFile(file);
  };

  async function handleFirmwareFile(file) {
    if (!file.name.endsWith(".bin")) {
      alert("Please select a .bin firmware file.");
      return;
    }
    firmwareName = file.name;
    filenameEl.textContent = firmwareName;
    firmwareBuffer = await file.arrayBuffer();
    appendLog("Loaded local firmware: " + firmwareName + " (" + file.size + " bytes)");
  }

  // ========= FLASH HELPERS =========
  async function ensureConnectedForFlash() {
    if (!devicePort || !esploader) {
      throw new Error("Device not connected. Click 'Connect & Detect' first.");
    }
  }

  async function writeMergedBin(buffer, labelForHistory, addressOverride) {
    await ensureConnectedForFlash();

    const address = addressOverride != null ? addressOverride : parseHexOrDec(flashAddressInput?.value || "0");
    const flashSize = flashSizeSelect?.value || "keep";
    const flashMode = flashModeSelect?.value || "keep";
    const flashFreq = flashFreqSelect?.value || "keep";

    setStatus("Flashing‚Ä¶", "connected");
    setProgress(2);
    appendLog("Starting flash‚Ä¶ (address 0x" + address.toString(16) + ")");

    const uint8 = new Uint8Array(buffer);
    let binStr = "";
    for (let i = 0; i < uint8.length; i++) {
      binStr += String.fromCharCode(uint8[i]);
    }

    const fileArray = [
      {
        data: binStr,
        address: address,
      },
    ];

    try {
      await esploader.writeFlash({
        fileArray,
        flashSize,
        flashMode,
        flashFreq,
        eraseAll: false,
        compress: true,
        reportProgress: (fileIndex, written, total) => {
          const pct = Math.floor((written / total) * 100);
          setProgress(pct);
          setStatus("Flashing‚Ä¶ " + pct + "%", "connected");
        },
      });

      setProgress(100);
      setStatus("Flash done", "connected");
      appendLog("Flash finished successfully.");
      addHistoryEntry({
        type: "local",
        name: labelForHistory || firmwareName || "local.bin",
      });
      recordFlashAttempt(true);

      try {
        await esploader.after("hard_reset");
      } catch (e) {}
    } catch (e) {
      console.error(e);
      appendLog("Flash error: " + e);
      setStatus("Flash error", "error");
      recordFlashAttempt(false);
      throw e;
    }
  }

  document.getElementById("flashLocalBtn").onclick = async () => {
    if (!firmwareBuffer) {
      alert("Select a .bin firmware first.");
      return;
    }
    try {
      await writeMergedBin(firmwareBuffer, firmwareName);
    } catch (_) {}
  };

  const MULTI_FILE_DEFAULTS = ["0x1000", "0x8000", "0x10000"];

  function addMultiFileRow(defaultAddress) {
    if (!multiFileContainer) return;
    const row = document.createElement("div");
    row.className = "multi-file-row";
    const fileId = "multiFile_" + Date.now() + "_" + Math.random().toString(36).slice(2, 6);
    const fileInput = document.createElement("input");
    fileInput.type = "file";
    fileInput.accept = ".bin";
    fileInput.id = fileId;
    fileInput.className = "multi-file-input";
    const label = document.createElement("span");
    label.className = "file-label";
    label.textContent = "Choose .bin";
    label.htmlFor = fileId;
    label.title = "Click to select file";
    fileInput.addEventListener("change", () => {
      const f = fileInput.files && fileInput.files[0];
      label.textContent = f ? f.name : "Choose .bin";
      label.classList.toggle("has-file", !!f);
    });
    const addrInput = document.createElement("input");
    addrInput.type = "text";
    addrInput.className = "addr-input mono";
    addrInput.placeholder = "0x0";
    addrInput.value = defaultAddress || "0x10000";
    addrInput.title = "Flash address (hex)";
    const removeBtn = document.createElement("button");
    removeBtn.type = "button";
    removeBtn.className = "secondary btn-small remove-row";
    removeBtn.textContent = "Remove";
    removeBtn.addEventListener("click", () => row.remove());
    row.appendChild(fileInput);
    row.appendChild(label);
    row.appendChild(addrInput);
    row.appendChild(removeBtn);
    multiFileContainer.appendChild(row);
  }

  addMultiFileBtn?.addEventListener("click", () => {
    const rows = multiFileContainer?.querySelectorAll(".multi-file-row") || [];
    const nextDefault = MULTI_FILE_DEFAULTS[rows.length] || "0x10000";
    addMultiFileRow(nextDefault);
  });

  async function writeMultipleBins(entries) {
    await ensureConnectedForFlash();
    const flashSize = flashSizeSelect?.value || "keep";
    const flashMode = flashModeSelect?.value || "keep";
    const flashFreq = flashFreqSelect?.value || "keep";
    setStatus("Flashing‚Ä¶", "connected");
    setProgress(2);
    appendLog("Starting multi-file flash (" + entries.length + " file(s))‚Ä¶");
    const sorted = [...entries].sort((a, b) => a.address - b.address);
    const fileArray = [];
    for (let i = 0; i < sorted.length; i++) {
      const { buffer, address } = sorted[i];
      const uint8 = new Uint8Array(buffer);
      let binStr = "";
      for (let j = 0; j < uint8.length; j++) binStr += String.fromCharCode(uint8[j]);
      fileArray.push({ data: binStr, address });
      appendLog("  [" + i + "] 0x" + address.toString(16) + " (" + buffer.byteLength + " bytes)");
    }
    try {
      await esploader.writeFlash({
        fileArray,
        flashSize,
        flashMode,
        flashFreq,
        eraseAll: false,
        compress: true,
        reportProgress: (fileIndex, written, total) => {
          const pct = Math.floor((written / total) * 100);
          setProgress(pct);
          setStatus("Flashing‚Ä¶ " + pct + "%", "connected");
        },
      });
      setProgress(100);
      setStatus("Flash done", "connected");
      appendLog("Multi-file flash finished successfully.");
      addHistoryEntry({ type: "local", name: entries.length + " files" });
      recordFlashAttempt(true);
      try {
        await esploader.after("hard_reset");
      } catch (e) {}
    } catch (e) {
      console.error(e);
      appendLog("Flash error: " + e);
      setStatus("Flash error", "error");
      recordFlashAttempt(false);
      throw e;
    }
  }

  flashAllMultiBtn?.addEventListener("click", async () => {
    const rows = multiFileContainer?.querySelectorAll(".multi-file-row") || [];
    const entries = [];
    for (const row of rows) {
      const fileInput = row.querySelector(".multi-file-input");
      const addrInput = row.querySelector(".addr-input");
      const file = fileInput?.files && fileInput.files[0];
      if (!file || !addrInput) continue;
      const address = parseHexOrDec(addrInput.value);
      entries.push({ file, address });
    }
    if (entries.length === 0) {
      alert("Add at least one file with 'Add file + address', then choose a .bin and click Flash all.");
      return;
    }
    const missing = entries.filter((e) => !e.file.name);
    if (missing.length) {
      alert("Every row must have a .bin file selected.");
      return;
    }
    try {
      const buffers = await Promise.all(entries.map((e) => e.file.arrayBuffer()));
      const payload = entries.map((e, i) => ({ buffer: buffers[i], address: e.address }));
      await writeMultipleBins(payload);
    } catch (e) {
      appendLog("Multi-file error: " + formatError(e));
    }
  });

  document.getElementById("eraseBtn").onclick = async () => {
    try {
      await ensureConnectedForFlash();
      if (!confirm("Full erase will wipe the entire flash. Continue?")) return;
      setStatus("Erasing flash‚Ä¶", "connected");
      appendLog("Erasing flash‚Ä¶ (this can take a while)");
      await esploader.eraseFlash();
      setStatus("Erase done", "connected");
      appendLog("Erase finished.");
    } catch (e) {
      appendLog("Erase error: " + e);
      setStatus("Erase error", "error");
    }
  };

  async function readFlashAndDownload() {
    await ensureConnectedForFlash();
    const addr = parseHexOrDec(regionAddressInput?.value || "0");
    const size = parseHexOrDec(regionSizeInput?.value || "0x1000");
    if (size <= 0) {
      appendLog("Read flash: size must be > 0");
      return;
    }
    setStatus("Reading flash‚Ä¶", "connected");
    appendLog("Reading flash 0x" + addr.toString(16) + " size " + size + "‚Ä¶");
    try {
      const data = await esploader.readFlash(addr, size);
      let bytes = data;
      if (typeof data === "string") {
        bytes = new Uint8Array([...data].map((c) => c.charCodeAt(0) & 0xff));
      } else if (!(data instanceof Uint8Array)) {
        bytes = new Uint8Array(data);
      }
      const blob = new Blob([bytes], { type: "application/octet-stream" });
      const a = document.createElement("a");
      a.href = URL.createObjectURL(blob);
      a.download = "flash_read_0x" + addr.toString(16) + "_" + size + ".bin";
      a.click();
      URL.revokeObjectURL(a.href);
      setStatus("Read done", "connected");
      appendLog("Read finished. Downloaded " + size + " bytes.");
    } catch (e) {
      appendLog("Read flash error: " + formatError(e));
      setStatus("Read error", "error");
    }
  }

  document.getElementById("readFlashBtn").onclick = readFlashAndDownload;

  document.getElementById("eraseRegionBtn").onclick = async () => {
    await ensureConnectedForFlash();
    const addr = parseHexOrDec(regionAddressInput?.value || "0");
    const size = parseHexOrDec(regionSizeInput?.value || "0x1000");
    if (size <= 0) {
      appendLog("Erase region: size must be > 0");
      return;
    }
    if (!confirm("Erase " + size + " bytes from 0x" + addr.toString(16) + "? This cannot be undone.")) return;
    setStatus("Erasing region‚Ä¶", "connected");
    appendLog("Erasing region 0x" + addr.toString(16) + " size " + size + "‚Ä¶");
    try {
      if (typeof esploader.eraseRegion === "function") {
        await esploader.eraseRegion(addr, size);
      } else {
        appendLog("Erase region not available in this esptool-js version. Use full erase instead.");
        setStatus("Idle");
        return;
      }
      setStatus("Erase done", "connected");
      appendLog("Erase region finished.");
    } catch (e) {
      appendLog("Erase region error: " + formatError(e));
      setStatus("Erase error", "error");
    }
  };

  document.getElementById("md5FlashBtn").onclick = async () => {
    await ensureConnectedForFlash();
    const addr = parseHexOrDec(regionAddressInput?.value || "0");
    const size = parseHexOrDec(regionSizeInput?.value || "0x1000");
    if (size <= 0) {
      appendLog("MD5: size must be > 0");
      return;
    }
    setStatus("Computing MD5‚Ä¶", "connected");
    appendLog("MD5 0x" + addr.toString(16) + " size " + size + "‚Ä¶");
    try {
      const md5 = await esploader.flashMd5sum(addr, size);
      setStatus("Idle");
      appendLog("MD5: " + md5);
    } catch (e) {
      appendLog("MD5 error: " + formatError(e));
      setStatus("MD5 error", "error");
    }
  };

  // ========= GITHUB RELEASES / OTA =========
  document.getElementById("flashRemoteBtn").onclick = async () => {
    if (!selectedRemoteAsset) {
      alert("Select a remote firmware from the list first.");
      return;
    }
    const plan = buildWritePlanSelected(selectedRemoteAsset);
    if (!confirmWritePlan(plan)) {
      appendLog("Remote flash cancelled.");
      return;
    }
    try {
      await ensureConnectedForFlash();
      appendLog("Downloading remote firmware: " + selectedRemoteAsset.name);
      setStatus("Downloading remote firmware‚Ä¶", "connected");
      const buf = await downloadRemoteFirmware(selectedRemoteAsset);
      appendLog("Download complete (" + buf.byteLength + " bytes).");
      await writeMergedBin(buf, selectedRemoteAsset.name);
      addHistoryEntry({
        type: "remote",
        name: selectedRemoteAsset.name,
      });
    } catch (e) {
      const msg = formatError(e);
      const hint = hintForError(e);
      appendLog("Remote flash error: " + msg);
      if (hint) appendLog("Hint: " + hint);
      setStatus("Remote flash error", "error");
    }
  };

  document.getElementById("flashFullSetBtn").onclick = async () => {
    const releaseTag =
      activeReleaseTag ||
      selectedRemoteAsset?.releaseTag ||
      (githubAssets[0] && githubAssets[0].releaseTag);
    const assets = getAssetsInRelease(releaseTag);
    if (!assets.length) {
      alert("No .bin files in this release. Select a project with a release that has firmware assets.");
      return;
    }
    const plan = buildWritePlanFullSet(releaseTag);
    if (!confirmWritePlan(plan)) {
      appendLog("Flash full set cancelled.");
      return;
    }
    try {
      await ensureConnectedForFlash();
      const entries = [];
      const n = assets.length;
      for (let i = 0; i < n; i++) {
        const asset = assets[i];
        setStatus("Downloading " + (i + 1) + "/" + n + "‚Ä¶", "connected");
        appendLog("Downloading " + (i + 1) + "/" + n + ": " + asset.name);
        const buf = await downloadRemoteFirmware(asset);
        entries.push({ buffer: buf, address: suggestAddressForAsset(asset.name) });
      }
      appendLog("All downloads complete. Flashing " + n + " file(s)‚Ä¶");
      await writeMultipleBins(entries);
    } catch (e) {
      const msg = formatError(e);
      const hint = hintForError(e);
      appendLog("Flash full set error: " + msg);
      if (hint) appendLog("Hint: " + hint);
      setStatus("Flash full set error", "error");
    }
  };

  if (openDownloadBtn) {
    openDownloadBtn.onclick = async () => {
      if (!selectedRemoteAsset) {
        alert("Select a remote firmware first.");
        return;
      }
      const url = selectedRemoteAsset.url;
      appendLog("Opening download in a new tab: " + selectedRemoteAsset.name);
      // This uses normal browser navigation/download and avoids CORS fetch restrictions.
      const w = window.open(url, "_blank", "noopener,noreferrer");
      if (!w) {
        alert("Popup blocked. Allow popups for this site, or use 'Copy OTA URL'.");
      }
    };
  }

  if (flashUrlBtn) {
    flashUrlBtn.onclick = async () => {
      const url = (remoteUrlInput?.value || "").trim();
      if (!url) {
        alert("Paste a direct .bin URL first.");
        return;
      }
      if (!/^https?:\/\//i.test(url)) {
        alert("URL must start with http:// or https://");
        return;
      }
      try {
        await ensureConnectedForFlash();
        appendLog("Downloading firmware from URL‚Ä¶");
        setStatus("Downloading URL firmware‚Ä¶", "connected");
        const buf = await fetchArrayBuffer(url, { cache: "no-store" });
        appendLog("Download complete (" + buf.byteLength + " bytes).");
        await writeMergedBin(buf, url.split("/").pop() || "url.bin");
        addHistoryEntry({ type: "url", name: url });
      } catch (e) {
        const msg = formatError(e);
        appendLog("URL flash error: " + msg);
        if (looksLikeCorsOrNetworkFetchFailure(e)) {
          appendLog(
            "Hint: That host may not allow browser downloads (CORS). Try a CORS-friendly host (or download in a tab and flash locally)."
          );
        }
        setStatus("URL flash error", "error");
      }
    };
  }

  document.getElementById("copyOtaUrlBtn").onclick = async () => {
    if (!selectedRemoteAsset) {
      alert("Select a remote firmware first.");
      return;
    }
    const url = selectedRemoteAsset.url;
    try {
      await navigator.clipboard.writeText(url);
      alert("OTA URL copied:\\n" + url);
    } catch (_) {
      alert("OTA URL:\\n" + url);
    }
  };

  // ========= SERIAL CONSOLE =========
  async function closeConsole() {
    try {
      if (consoleReader) {
        await consoleReader.cancel();
      }
    } catch (_) {}
    try {
      if (consolePort && consolePort.readable) {
        await consolePort.close();
      }
    } catch (_) {}
    consolePort = null;
    consoleReader = null;
    consoleWriter = null;
    appendConsole("[console] closed");
  }

  function appendConsole(msg) {
    const time = new Date().toLocaleTimeString();
    consoleLog.textContent += "[" + time + "] " + msg + "\\n";
    consoleLog.scrollTop = consoleLog.scrollHeight;
  }

  document.getElementById("openConsoleBtn").onclick = async () => {
    try {
      const usable = webSerialUsable();
      if (!usable.ok) {
        alert(usable.reason);
        appendConsole("[console] " + usable.reason);
        return;
      }

      // The port can't be opened twice; close flasher connection first if needed.
      if (devicePort) {
        appendConsole("[console] closing flasher connection to free the port‚Ä¶");
        await cleanupDeviceConnection({ statusTextOverride: "Idle" });
      }
      await closeConsole();

      const baud = parseInt(baudSelect.value, 10) || 115200;
      consolePort = await navigator.serial.requestPort();
      appendConsole("[console] port selected" + portInfoString(consolePort));
      await consolePort.open({ baudRate: baud });

      appendConsole("[console] opened @ " + baud + " baud");

      const decoder = new TextDecoderStream();
      const encoder = new TextEncoderStream();

      consolePort.readable.pipeTo(decoder.writable);
      encoder.readable.pipeTo(consolePort.writable);

      consoleReader = decoder.readable.getReader();
      consoleWriter = encoder.writable.getWriter();

      (async () => {
        try {
          while (true) {
            const { value, done } = await consoleReader.read();
            if (done) break;
            if (value) {
              consoleLog.textContent += value;
              consoleLog.scrollTop = consoleLog.scrollHeight;
            }
          }
        } catch (err) {
          console.error(err);
        }
      })();
    } catch (e) {
      console.error(e);
      const msg = formatError(e);
      const hint = hintForError(e);
      appendConsole("[console] error: " + msg);
      if (hint) appendConsole("[console] hint: " + hint);
    }
  };

  closeConsoleBtn.onclick = async () => {
    await closeConsole();
  };

  document.getElementById("consoleSendBtn").onclick = async () => {
    if (!consoleWriter) {
      alert("Open the console first.");
      return;
    }
    const text = consoleInput.value;
    if (!text) return;
    try {
      await consoleWriter.write(text + "\\n");
      appendConsole("> " + text);
      consoleInput.value = "";
    } catch (e) {
      appendConsole("[console] send error: " + e);
    }
  };

  consoleInput.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      document.getElementById("consoleSendBtn").click();
    }
  });

  // ========= SUBMISSION FLOW =========
  async function computeFileSha256(file) {
    try {
      const buffer = await file.arrayBuffer();
      const hashBuffer = await crypto.subtle.digest("SHA-256", buffer);
      const hashArray = Array.from(new Uint8Array(hashBuffer));
      const hashHex = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
      return hashHex;
    } catch (e) {
      console.error("SHA-256 computation failed:", e);
      return null;
    }
  }

  if (submitFirmwareFile) {
    submitFirmwareFile.addEventListener("change", async (e) => {
      const file = e.target.files[0];
      if (!file) {
        submitFirmwareHash.textContent = "SHA-256: ‚Äî";
        submitFileMeta = null;
        return;
      }
      submitFirmwareHash.textContent = "SHA-256: Computing‚Ä¶";
      const hash = await computeFileSha256(file);
      if (hash) {
        submitFirmwareHash.textContent = "SHA-256: " + hash;
        submitFileMeta = { name: file.name, size: file.size, hash };
      } else {
        submitFirmwareHash.textContent = "SHA-256: Error";
        submitFileMeta = null;
      }
    });
  }

  if (submitProjectSelect) {
    submitProjectSelect.addEventListener("change", () => {
      const v = submitProjectSelect.value;
      if (v !== "custom") {
        const project = projectCatalog.find((p) => p.id === v);
        if (project) {
          if (submitProjectName) submitProjectName.value = project.name;
          if (submitChip && !submitChip.value) submitChip.value = project.chipFamily || "";
        }
      }
    });
  }

  function buildSubmissionIssue() {
    const projectName = (submitProjectName?.value || "").trim();
    const chip = (submitChip?.value || "").trim();
    const firmwareName = (submitFirmwareName?.value || "").trim();
    const version = (submitFirmwareVersion?.value || "").trim();
    const url = (submitFirmwareUrl?.value || "").trim();
    const repo = (submitRepoInput?.value || "cifertech/FirmwareHub").trim();

    if (!projectName) {
      alert("Project name is required.");
      return null;
    }
    if (!firmwareName) {
      alert("Firmware name is required.");
      return null;
    }

    const title = "Firmware Submission: " + projectName + " - " + firmwareName + (version ? " " + version : "");
    
    let body = "## Firmware Submission\\n\\n";
    body += "**Project:** " + projectName + "\\n";
    body += "**Target Chip:** " + (chip || "Not specified") + "\\n";
    body += "**Firmware Name:** " + firmwareName + "\\n";
    body += "**Version:** " + (version || "Not specified") + "\\n";
    body += "**Download URL:** " + (url || "Not provided (see attachment)") + "\\n";
    
    if (submitFileMeta) {
      body += "\\n### File Information\\n";
      body += "**File Name:** " + submitFileMeta.name + "\\n";
      body += "**File Size:** " + submitFileMeta.size + " bytes\\n";
      body += "**SHA-256:** `" + submitFileMeta.hash + "`\\n";
      body += "\\n_Please attach the .bin file to this issue._\\n";
    } else if (!url) {
      body += "\\n_Please attach the .bin file to this issue or provide a download URL._\\n";
    }

    body += "\\n---\\n";
    body += "_This submission will be reviewed manually before being added to the catalog._";

    const issueUrl = 
      "https://github.com/" + repo + "/issues/new" +
      "?title=" + encodeURIComponent(title) +
      "&body=" + encodeURIComponent(body);

    return issueUrl;
  }

  if (buildIssueBtn) {
    buildIssueBtn.addEventListener("click", () => {
      const issueUrl = buildSubmissionIssue();
      if (issueUrl) {
        issueLink.href = issueUrl;
        issueLink.textContent = "Open issue form (ready)";
        appendLog("Issue link generated. Click 'Open issue form' to submit.");
      }
    });
  }

  if (issueLink) {
    issueLink.addEventListener("click", (e) => {
      if (issueLink.href === "#" || issueLink.href.endsWith("#")) {
        e.preventDefault();
        alert("Click 'Create GitHub Issue' first to generate the submission link.");
      }
    });
  }

  if (copyIssueBtn) {
    copyIssueBtn.addEventListener("click", async () => {
      const issueUrl = buildSubmissionIssue();
      if (!issueUrl) return;
      try {
        await navigator.clipboard.writeText(issueUrl);
        alert("Issue link copied to clipboard!");
      } catch (_) {
        alert("Issue link:\\n" + issueUrl);
      }
    });
  }

  if (projectSearch) {
    projectSearch.addEventListener("input", () => {
      renderProjectCards();
    });
  }

  if (assetSearch) {
    assetSearch.addEventListener("input", () => {
      renderRemoteReleaseGroups({ query: assetSearch.value });
      updateRemoteActionsUi();
      updateReleaseSetPreview();
    });
  }

  if (remoteShowPrereleases) {
    remoteShowPrereleases.addEventListener("change", () => {
      renderRemoteReleaseGroups();
      updateRemoteActionsUi();
      updateReleaseSetPreview();
    });
  }

  if (remoteShowAllAssets) {
    remoteShowAllAssets.addEventListener("change", () => {
      renderRemoteReleaseGroups();
    });
  }

  // ========= CHANGELOG & VERSION COMPARISON =========
  function showChangelog() {
    const repo = repoInput.value.trim();
    if (!repo || !releasesCache[repo]) {
      alert("No releases loaded. Refresh releases first.");
      return;
    }

    const releases = releasesCache[repo];
    changelogTitle.textContent = "Release Notes - " + repo;
    changelogBody.innerHTML = "";

    if (!releases.length) {
      changelogBody.innerHTML = '<div class="value-soft">No releases found.</div>';
      changelogModal.classList.add("visible");
      return;
    }

    releases.forEach((release) => {
      const releaseDiv = document.createElement("div");
      releaseDiv.className = "changelog-release";

      const header = document.createElement("div");
      header.className = "changelog-release-header";

      const version = document.createElement("div");
      version.className = "changelog-version";
      version.textContent = release.tag_name || release.name || "Unknown";

      const date = document.createElement("div");
      date.className = "changelog-date";
      if (release.published_at) {
        const d = new Date(release.published_at);
        date.textContent = d.toLocaleDateString() + " " + d.toLocaleTimeString();
      }

      header.appendChild(version);
      header.appendChild(date);

      const notes = document.createElement("div");
      notes.className = "changelog-notes";
      notes.textContent = release.body || "No release notes provided.";

      releaseDiv.appendChild(header);
      releaseDiv.appendChild(notes);
      changelogBody.appendChild(releaseDiv);
    });

    changelogModal.classList.add("visible");
    // Move focus into the dialog for accessibility
    if (closeChangelogBtn) {
      closeChangelogBtn.focus();
    } else if (changelogModal) {
      changelogModal.focus();
    }
  }

  if (viewChangelogBtn) {
    viewChangelogBtn.addEventListener("click", showChangelog);
  }

  if (closeChangelogBtn) {
    closeChangelogBtn.addEventListener("click", () => {
      changelogModal.classList.remove("visible");
    });
  }

  if (changelogModal) {
    changelogModal.addEventListener("click", (e) => {
      if (e.target === changelogModal) {
        changelogModal.classList.remove("visible");
      }
    });
  }

  // ========= STATISTICS =========
  if (clearStatsBtn) {
    clearStatsBtn.addEventListener("click", () => {
      if (confirm("Clear all flash statistics?")) {
        flashStats = { total: 0, success: 0, failures: 0, lastFlash: null };
        saveFlashStats();
        updateStats();
      }
    });
  }

  // Update stats periodically
  setInterval(updateStats, 60000); // Every minute

  // ========= UPDATE NOTIFICATIONS =========
  let lastKnownReleases = {};

  function checkForUpdates() {
    if (!projectCatalog.length) return;

    projectCatalog.forEach(async (project) => {
      const projectId = project.id;

      try {
        const url = "https://api.github.com/repos/" + project.repo + "/releases";
        const res = await fetch(url);
        if (!res.ok) return;
        const releases = await res.json();
        
        if (releases.length > 0) {
          const latestTag = releases[0].tag_name;
          const lastKnown = lastKnownReleases[projectId];
          
          if (lastKnown && lastKnown !== latestTag) {
            // New release detected!
            appendLog("üîî Update available for " + project.name + ": " + latestTag);
            if (Notification.permission === "granted") {
              new Notification("FirmwareHub Update", {
                body: project.name + " has a new release: " + latestTag,
                icon: "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='0.9em' font-size='90'>üöÄ</text></svg>"
              });
            }
          }
          
          lastKnownReleases[projectId] = latestTag;
        }
      } catch (e) {
        // Silently fail
      }
    });

    try {
      localStorage.setItem("cifertech_flasher_known_releases", JSON.stringify(lastKnownReleases));
    } catch (e) {}
  }

  function loadKnownReleases() {
    try {
      const raw = localStorage.getItem("cifertech_flasher_known_releases");
      if (raw) lastKnownReleases = JSON.parse(raw);
    } catch (e) {}
  }

  function requestNotificationPermission() {
    if ("Notification" in window && Notification.permission === "default") {
      Notification.requestPermission();
    }
  }

  loadKnownReleases();
  
  // Check for updates every 10 minutes
  setInterval(checkForUpdates, 600000);
  
  // Check on visibility change
  document.addEventListener("visibilitychange", () => {
    if (!document.hidden) {
      checkForUpdates();
    }
  });

  // Request notification permission after first interaction
  document.addEventListener("click", requestNotificationPermission, { once: true });

  // ========= INIT =========
  setConnectionUi(false);
  setStatus("Idle");

  // Update UI immediately if WebSerial can't work in this context.
  const usable = webSerialUsable();
  if (!usable.ok) {
    setStatus("WebSerial unavailable", "error");
    appendLog(usable.reason);
    if (connectBtn) connectBtn.disabled = true;
    if (openConsoleBtn) openConsoleBtn.disabled = true;
  }

  // Handle unplug / OS disconnect events.
  if ("serial" in navigator) {
    navigator.serial.addEventListener("disconnect", async (event) => {
      const disconnectedPort = event?.target || event?.port || null;
      if (disconnectedPort && devicePort && disconnectedPort === devicePort) {
        appendLog("Device disconnected.");
        await cleanupDeviceConnection({ statusTextOverride: "Disconnected" });
      }
      if (disconnectedPort && consolePort && disconnectedPort === consolePort) {
        appendConsole("[console] device disconnected");
        await closeConsole();
      }
    });
  }
</script>

</body>
</html>
